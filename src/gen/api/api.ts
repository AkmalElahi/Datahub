/* tslint:disable */
/* eslint-disable */
/**
 * DataHub Server API
 * REST API for DataHub Server and Client Communication
 *
 * The version of the OpenAPI document: 2.0
 * Contact: igushev@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Airtable Data Source of data to create a Product or add a Table.
 * @export
 * @interface AirtableDataSource
 */
export interface AirtableDataSource {
    /**
     * Base ID provided by Maker.
     * @type {string}
     * @memberof AirtableDataSource
     */
    base_id?: string;
    /**
     * Table name as seen my Maker in Airtable, no need to escape.
     * @type {string}
     * @memberof AirtableDataSource
     */
    table_name?: string;
    /**
     * API Key provided by Maker.
     * @type {string}
     * @memberof AirtableDataSource
     */
    api_key?: string;
}
/**
 * Filter for boolean columns.
 * @export
 * @interface BooleanFilter
 */
export interface BooleanFilter {
    /**
     * If user has selected a value.
     * @type {boolean}
     * @memberof BooleanFilter
     */
    has_selected?: boolean | null;
    /**
     * Value if user has selected one.
     * @type {boolean}
     * @memberof BooleanFilter
     */
    selected_value?: boolean | null;
}
/**
 * CSV Data Source of data to create a Product or add a Table.
 * @export
 * @interface CSVDataSource
 */
export interface CSVDataSource {
    /**
     * Filename generated by Backend and returned via /upload_file.
     * @type {string}
     * @memberof CSVDataSource
     */
    filename?: string | null;
    /**
     * Publish ULR link to the file.
     * @type {string}
     * @memberof CSVDataSource
     */
    file_link?: string | null;
    /**
     * If CSV file has header. If null, Backend will infer from file.
     * @type {boolean}
     * @memberof CSVDataSource
     */
    has_header?: boolean | null;
}
/**
 * Describes how to display a Card.
 * @export
 * @interface CardViewMetadata
 */
export interface CardViewMetadata {
    /**
     * Title of the View. Not attach to a row, but for overall View. In Most cases will be seen by Maker.
     * @type {string}
     * @memberof CardViewMetadata
     */
    title?: string | null;
    /**
     * Column name to use to display a Card title.
     * @type {string}
     * @memberof CardViewMetadata
     */
    title_column?: string | null;
    /**
     * Column name to use to display a Card subtitle.
     * @type {string}
     * @memberof CardViewMetadata
     */
    subtitle_column?: string | null;
    /**
     * Column name to use to display a Card subtitle.
     * @type {string}
     * @memberof CardViewMetadata
     */
    description_column?: string | null;
    /**
     * Column name to use to reference an image to display on left upper corner of a Card.
     * @type {string}
     * @memberof CardViewMetadata
     */
    image_url_column?: string | null;
    /**
     * List of references to Columns to display.
     * @type {Array<ColumnViewMetadata>}
     * @memberof CardViewMetadata
     */
    column_view_list?: Array<ColumnViewMetadata> | null;
    /**
     * List of references to Views which are embedded as Nested Tables. For example, for a Movie, it can diplay Actors, Shooting Locations, Awards.
     * @type {Array<NestedViewMetadata>}
     * @memberof CardViewMetadata
     */
    nested_view_list?: Array<NestedViewMetadata> | null;
}
/**
 * ColumnMetadata as it is stored in MetadataStore.
 * @export
 * @interface ColumnMetadata
 */
export interface ColumnMetadata {
    /**
     * A unique name as referenced by system and in scripts. Subject to regular variable name rules.
     * @type {string}
     * @memberof ColumnMetadata
     */
    name?: string;
    /**
     * Name of the Table the Column belongs to.
     * @type {string}
     * @memberof ColumnMetadata
     */
    table_name?: string;
    /**
     * Name of the Product the Table belongs to.
     * @type {string}
     * @memberof ColumnMetadata
     */
    product_name?: string;
    /**
     * Title as seen by End User if applicable.
     * @type {string}
     * @memberof ColumnMetadata
     */
    title?: string | null;
    /**
     * Few sentences long description as seen by End User if applicable.
     * @type {string}
     * @memberof ColumnMetadata
     */
    description?: string | null;
    /**
     * Numeric value for data type (0 - int, 1 - float, 2 - string, 3 - boolean)
     * @type {number}
     * @memberof ColumnMetadata
     */
    data_type?: number | null;
    /**
     * If the column is primary key in the Table.
     * @type {boolean}
     * @memberof ColumnMetadata
     */
    is_primary_key?: boolean | null;
    /**
     * Name of actual Entity currently assigned to this column.
     * @type {string}
     * @memberof ColumnMetadata
     */
    entity_name?: string | null;
    /**
     * Numeric position of the Column in the Table.
     * @type {number}
     * @memberof ColumnMetadata
     */
    column_num?: number | null;
    /**
     * If column were added by the platform.
     * @type {boolean}
     * @memberof ColumnMetadata
     */
    generated?: boolean | null;
    /**
     * List of entities which can be chosen for this column in order of best matching to least matching.
     * @type {Array<string>}
     * @memberof ColumnMetadata
     */
    entity_name_candidate_list?: Array<string> | null;
    /**
     * 
     * @type {ViewFilter}
     * @memberof ColumnMetadata
     */
    view_filter?: ViewFilter;
}
/**
 * For given column specifies possible and applied filters.
 * @export
 * @interface ColumnMetadataViewFilter
 */
export interface ColumnMetadataViewFilter {
    /**
     * 
     * @type {ColumnMetadata}
     * @memberof ColumnMetadataViewFilter
     */
    column_metadata?: ColumnMetadata;
    /**
     * 
     * @type {ViewFilter}
     * @memberof ColumnMetadataViewFilter
     */
    view_filter?: ViewFilter;
}
/**
 * Reference to a Column to display to User.
 * @export
 * @interface ColumnViewMetadata
 */
export interface ColumnViewMetadata {
    /**
     * Product name to display.
     * @type {string}
     * @memberof ColumnViewMetadata
     */
    product_name?: string;
    /**
     * Taable name to display.
     * @type {string}
     * @memberof ColumnViewMetadata
     */
    table_name?: string;
    /**
     * Column name to display.
     * @type {string}
     * @memberof ColumnViewMetadata
     */
    column_name?: string;
    /**
     * Title as seen by End User if applicable.
     * @type {string}
     * @memberof ColumnViewMetadata
     */
    title?: string | null;
    /**
     * Column Name in original displayed Table which is used to connect to this additional table. Only appicable when ColumnViewMetadata references to Table or Product other then original displayed Table.
     * @type {string}
     * @memberof ColumnViewMetadata
     */
    column_name_from?: string | null;
    /**
     * Column Name in additional table which is used to connect to original displayed Table. Only appicable when ColumnViewMetadata references to Table or Product other then original displayed Table.
     * @type {string}
     * @memberof ColumnViewMetadata
     */
    column_name_to?: string | null;
    /**
     * If End User can filter by this column in table view.
     * @type {boolean}
     * @memberof ColumnViewMetadata
     */
    add_filter?: boolean | null;
    /**
     * 
     * @type {OnClickViewMetadata}
     * @memberof ColumnViewMetadata
     */
    on_click_view?: OnClickViewMetadata;
}
/**
 * Data Source of data to create a Product or add a Table.
 * @export
 * @interface DataSource
 */
export interface DataSource {
    /**
     * 
     * @type {CSVDataSource}
     * @memberof DataSource
     */
    csv_data_source?: CSVDataSource;
    /**
     * 
     * @type {AirtableDataSource}
     * @memberof DataSource
     */
    airtable_data_source?: AirtableDataSource;
}
/**
 * Specifies range of rows to display in Table. Allows pagination.
 * @export
 * @interface DisplayParams
 */
export interface DisplayParams {
    /**
     * Row to start from.
     * @type {number}
     * @memberof DisplayParams
     */
    offset?: number;
    /**
     * Number of rows.
     * @type {number}
     * @memberof DisplayParams
     */
    limit?: number;
    /**
     * Column name to sort by.
     * @type {string}
     * @memberof DisplayParams
     */
    sort_by?: string | null;
}
/**
 * Entity Metadata with all tags.
 * @export
 * @interface EntityFullMetadata
 */
export interface EntityFullMetadata {
    /**
     * 
     * @type {EntityMetadata}
     * @memberof EntityFullMetadata
     */
    entity_metadata?: EntityMetadata;
    /**
     * List of all entity tags.
     * @type {Array<EntityTag>}
     * @memberof EntityFullMetadata
     */
    entity_tag_list?: Array<EntityTag>;
}
/**
 * EntityMetadata as it is stored in MetadataStore. Entity is used to connect Product, Tables and Columns with each other when they refer or describe same objects in universe.
 * @export
 * @interface EntityMetadata
 */
export interface EntityMetadata {
    /**
     * A unique name as referenced by system and in scripts. Subject to regular variable name rules.
     * @type {string}
     * @memberof EntityMetadata
     */
    name?: string;
    /**
     * Title as seen by End User if applicable.
     * @type {string}
     * @memberof EntityMetadata
     */
    title?: string | null;
    /**
     * Few sentences long description as seen by End User if applicable.
     * @type {string}
     * @memberof EntityMetadata
     */
    description?: string | null;
}
/**
 * List of entities which can be chosen for given column in order of best matching to least matching.
 * @export
 * @interface EntityMetadataCandidateList
 */
export interface EntityMetadataCandidateList {
    /**
     * 
     * @type {ColumnMetadata}
     * @memberof EntityMetadataCandidateList
     */
    column_metadata?: ColumnMetadata;
    /**
     * List of entity candidates.
     * @type {Array<EntityMetadata>}
     * @memberof EntityMetadataCandidateList
     */
    entity_metadata_list?: Array<EntityMetadata>;
}
/**
 * EntityTag as it is stored in MetadataStore.
 * @export
 * @interface EntityTag
 */
export interface EntityTag {
    /**
     * A unique name as referenced by system and in scripts. Subject to regular variable name rules.
     * @type {string}
     * @memberof EntityTag
     */
    name?: string;
    /**
     * <Put Here>
     * @type {string}
     * @memberof EntityTag
     */
    entity_name?: string | null;
    /**
     * Tags for search and reference by End User.
     * @type {string}
     * @memberof EntityTag
     */
    tag?: string | null;
}
/**
 * Filter for string and tags columns.
 * @export
 * @interface EnumRangeFilter
 */
export interface EnumRangeFilter {
    /**
     * List of values End User can select.
     * @type {Array<string>}
     * @memberof EnumRangeFilter
     */
    all_value_list?: Array<string> | null;
    /**
     * List of values End User has selected.
     * @type {Array<string>}
     * @memberof EnumRangeFilter
     */
    selected_value_list?: Array<string> | null;
}
/**
 * Names and links to file when it\'s uploaded to Backend file storage.
 * @export
 * @interface FileParams
 */
export interface FileParams {
    /**
     * Category of file, possible values are \'image\', \'data\'.
     * @type {string}
     * @memberof FileParams
     */
    category?: string;
    /**
     * Filename generated by Backend. By this filename the file should be referenced in future.
     * @type {string}
     * @memberof FileParams
     */
    filename?: string;
    /**
     * Public link to access the file if requested when called /upload_file.
     * @type {string}
     * @memberof FileParams
     */
    public_link?: string;
}
/**
 * For given table, page or request specifies possible and applied filters.
 * @export
 * @interface FilterParams
 */
export interface FilterParams {
    /**
     * List of columns and specified possible and applied filter.
     * @type {Array<ColumnMetadataViewFilter>}
     * @memberof FilterParams
     */
    column_metadata_view_filter_list?: Array<ColumnMetadataViewFilter> | null;
}
/**
 * Filter for float columns.
 * @export
 * @interface FloatRangeFilter
 */
export interface FloatRangeFilter {
    /**
     * Lowest value End User can select.
     * @type {number}
     * @memberof FloatRangeFilter
     */
    lower_bound?: number | null;
    /**
     * From value End User has selected.
     * @type {number}
     * @memberof FloatRangeFilter
     */
    lower_selected?: number | null;
    /**
     * Highest value End User can select.
     * @type {number}
     * @memberof FloatRangeFilter
     */
    upper_bound?: number | null;
    /**
     * To value End User has selected.
     * @type {number}
     * @memberof FloatRangeFilter
     */
    upper_selected?: number | null;
}
/**
 * Filter for integer columns.
 * @export
 * @interface IntRangeFilter
 */
export interface IntRangeFilter {
    /**
     * Lowest value End User can select.
     * @type {number}
     * @memberof IntRangeFilter
     */
    lower_bound?: number | null;
    /**
     * From value End User has selected.
     * @type {number}
     * @memberof IntRangeFilter
     */
    lower_selected?: number | null;
    /**
     * Highest value End User can select.
     * @type {number}
     * @memberof IntRangeFilter
     */
    upper_bound?: number | null;
    /**
     * To value End User has selected.
     * @type {number}
     * @memberof IntRangeFilter
     */
    upper_selected?: number | null;
}
/**
 * Location if physical world.
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * Latitude
     * @type {number}
     * @memberof Location
     */
    lat?: number;
    /**
     * Longitude
     * @type {number}
     * @memberof Location
     */
    _long?: number;
}
/**
 * Filter for location distance.
 * @export
 * @interface LocationDistanceFilter
 */
export interface LocationDistanceFilter {
    /**
     * Highest value of distance End User can select.
     * @type {number}
     * @memberof LocationDistanceFilter
     */
    upper_bound?: number | null;
    /**
     * Current value End User has selected.
     * @type {number}
     * @memberof LocationDistanceFilter
     */
    selected?: number | null;
}
/**
 * Filter for location columns.
 * @export
 * @interface LocationFilter
 */
export interface LocationFilter {
    /**
     * 
     * @type {Location}
     * @memberof LocationFilter
     */
    upper_left_bound?: Location;
    /**
     * 
     * @type {Location}
     * @memberof LocationFilter
     */
    upper_left_selected?: Location;
    /**
     * 
     * @type {Location}
     * @memberof LocationFilter
     */
    lower_right_bound?: Location;
    /**
     * 
     * @type {Location}
     * @memberof LocationFilter
     */
    lower_right_selected?: Location;
}
/**
 * Product monetization.
 * @export
 * @interface Monetization
 */
export interface Monetization {
    /**
     * If monetize current Product. If True, Maker can see/enter price.
     * @type {boolean}
     * @memberof Monetization
     */
    monetization?: boolean;
    /**
     * Subscription price for current Product.
     * @type {number}
     * @memberof Monetization
     */
    price?: number;
}
/**
 * Reference to a View which is embedded as Nested Table (only) View on a Card View.
 * @export
 * @interface NestedViewMetadata
 */
export interface NestedViewMetadata {
    /**
     * Product name to display.
     * @type {string}
     * @memberof NestedViewMetadata
     */
    product_name?: string;
    /**
     * View name to display.
     * @type {string}
     * @memberof NestedViewMetadata
     */
    view_name?: string;
    /**
     * Column Name in original displayed Table which is used to connect to this Nested View.
     * @type {string}
     * @memberof NestedViewMetadata
     */
    column_name_from?: string | null;
    /**
     * Column Name in Nested View which is used to connect to original displayed Table.
     * @type {string}
     * @memberof NestedViewMetadata
     */
    column_name_to?: string | null;
    /**
     * Number of rows to display in Nested View.
     * @type {number}
     * @memberof NestedViewMetadata
     */
    limit_rows?: number | null;
    /**
     * If to show a More button if number of rows is more then limit_rows.
     * @type {boolean}
     * @memberof NestedViewMetadata
     */
    more_button?: boolean | null;
}
/**
 * Data and Metadata for a Nested View.
 * @export
 * @interface NestedViewPage
 */
export interface NestedViewPage {
    /**
     * 
     * @type {ViewMetadata}
     * @memberof NestedViewPage
     */
    view_metadata?: ViewMetadata;
    /**
     * 
     * @type {TableMetadata}
     * @memberof NestedViewPage
     */
    table_metadata?: TableMetadata;
    /**
     * List of ColumnMetadata of Nested View. OBSOLETE, Use view_metadata instead.
     * @type {Array<ColumnMetadata>}
     * @memberof NestedViewPage
     */
    column_metadata_list?: Array<ColumnMetadata>;
    /**
     * Actual values. Outer array is rows, inner array is cells.
     * @type {Array<Array<string>>}
     * @memberof NestedViewPage
     */
    value_list_list?: Array<Array<string>>;
}
/**
 * User, both Maker and End User received from frontend.
 * @export
 * @interface NewUser
 */
export interface NewUser {
    /**
     * User First Name.
     * @type {string}
     * @memberof NewUser
     */
    first_name?: string | null;
    /**
     * User Last Name.
     * @type {string}
     * @memberof NewUser
     */
    last_name?: string | null;
    /**
     * Name as other Users see it.
     * @type {string}
     * @memberof NewUser
     */
    display_name?: string | null;
    /**
     * User Email.
     * @type {string}
     * @memberof NewUser
     */
    email?: string;
    /**
     * Hash of User Password.
     * @type {string}
     * @memberof NewUser
     */
    password?: string;
}
/**
 * Reference to a View to show when User clicks on a displayed value.
 * @export
 * @interface OnClickViewMetadata
 */
export interface OnClickViewMetadata {
    /**
     * Product name to display.
     * @type {string}
     * @memberof OnClickViewMetadata
     */
    product_name?: string;
    /**
     * View name to display within a Product.
     * @type {string}
     * @memberof OnClickViewMetadata
     */
    view_name?: string;
    /**
     * A column which is used to identity what row to display to User. For example, when user clicks on a Movie title and Maker wants to display a Movie card, column_name should be name of the title column in Movies table.
     * @type {string}
     * @memberof OnClickViewMetadata
     */
    column_name?: string;
}
/**
 * Product Tab in Constructor mode and pre-fetched other Tabs. This tab is used to select Product name, title, homepage View, etc. and actually publish the Product.
 * @export
 * @interface ProductConstructor
 */
export interface ProductConstructor {
    /**
     * 
     * @type {ProductFullMetadata}
     * @memberof ProductConstructor
     */
    product_full_metadata?: ProductFullMetadata;
    /**
     * A subset of all Views in product which can can used as home page. Frontend should send back only view name inside home_page_view_name field back to Backend.
     * @type {Array<ViewMetadata>}
     * @memberof ProductConstructor
     */
    home_page_view_candidate_list?: Array<ViewMetadata>;
    /**
     * 
     * @type {ViewPage}
     * @memberof ProductConstructor
     */
    preview_view_page?: ViewPage;
    /**
     * 
     * @type {UserInfo}
     * @memberof ProductConstructor
     */
    user_info?: UserInfo;
}
/**
 * Product Metadata with all Tables and all Views.
 * @export
 * @interface ProductFullMetadata
 */
export interface ProductFullMetadata {
    /**
     * 
     * @type {ProductMetadata}
     * @memberof ProductFullMetadata
     */
    product_metadata?: ProductMetadata;
    /**
     * List of TableFullMetadata of all Tables of the Product.
     * @type {Array<TableFullMetadata>}
     * @memberof ProductFullMetadata
     */
    table_full_metadata_list?: Array<TableFullMetadata>;
    /**
     * List of ViewMetadata of all views of the Products.
     * @type {Array<ViewMetadata>}
     * @memberof ProductFullMetadata
     */
    view_metadata_list?: Array<ViewMetadata>;
}
/**
 * List of ProductMetadata.
 * @export
 * @interface ProductListPage
 */
export interface ProductListPage {
    /**
     * List of ProductMetadata.
     * @type {Array<ProductMetadata>}
     * @memberof ProductListPage
     */
    product_metadata_list?: Array<ProductMetadata>;
    /**
     * 
     * @type {UserInfo}
     * @memberof ProductListPage
     */
    user_info?: UserInfo;
}
/**
 * ProductMetadata as it is stored in MetadataStore.
 * @export
 * @interface ProductMetadata
 */
export interface ProductMetadata {
    /**
     * A unique name as referenced by system and in scripts. Subject to regular variable name rules.
     * @type {string}
     * @memberof ProductMetadata
     */
    name?: string;
    /**
     * Title as seen by End User if applicable.
     * @type {string}
     * @memberof ProductMetadata
     */
    title?: string | null;
    /**
     * Few sentences long description as seen by End User if applicable.
     * @type {string}
     * @memberof ProductMetadata
     */
    description?: string | null;
    /**
     * View which End User will see when visits home page of a Product. This is how End User starts navigating the Product.
     * @type {string}
     * @memberof ProductMetadata
     */
    home_page_view_name?: string | null;
    /**
     * URL of an image which appears in the header of a Product.
     * @type {string}
     * @memberof ProductMetadata
     */
    header_image_url?: string | null;
    /**
     * If Product is published. If True, product is published, can be reached via subdomain and available for End User. If False, Product is in draft state.
     * @type {boolean}
     * @memberof ProductMetadata
     */
    published?: boolean | null;
    /**
     * Owner\'s Obfusticated User Id.
     * @type {string}
     * @memberof ProductMetadata
     */
    owner_user_id?: string | null;
    /**
     * 
     * @type {Monetization}
     * @memberof ProductMetadata
     */
    monetization?: Monetization;
    /**
     * Numeric popularity value. Currentluy not used.
     * @type {number}
     * @memberof ProductMetadata
     */
    popularity?: number | null;
}
/**
 * List of ProductMetadata.
 * @export
 * @interface ProductMetadataList
 */
export interface ProductMetadataList {
    /**
     * List of ProductMetadata.
     * @type {Array<ProductMetadata>}
     * @memberof ProductMetadataList
     */
    product_metadata_list?: Array<ProductMetadata>;
}
/**
 * Store User and their Session information.
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * Session Id.
     * @type {string}
     * @memberof Session
     */
    id?: string;
    /**
     * Obfusticated User Id.
     * @type {string}
     * @memberof Session
     */
    user_id?: string;
    /**
     * Date/Time when Session where created.
     * @type {string}
     * @memberof Session
     */
    datetime_created?: string;
}
/**
 * Information about Session to send to Frontend.
 * @export
 * @interface SessionInfo
 */
export interface SessionInfo {
    /**
     * Session Id.
     * @type {string}
     * @memberof SessionInfo
     */
    id?: string;
}
/**
 * URL to redirect to to connect a Maker to their Stripe account.
 * @export
 * @interface StripeAccountLink
 */
export interface StripeAccountLink {
    /**
     * URL to redirect to to connect a Maker to their Stripe account.
     * @type {string}
     * @memberof StripeAccountLink
     */
    url?: string;
}
/**
 * Stripe Checkout Session for an End User to subscribe for a Product.
 * @export
 * @interface StripeCheckoutSession
 */
export interface StripeCheckoutSession {
    /**
     * Stripe Checkout Session Id to redirect to an End User to subscribe for a Product.
     * @type {string}
     * @memberof StripeCheckoutSession
     */
    session_id?: string;
    /**
     * Platform\'s Stripe Public Key.
     * @type {string}
     * @memberof StripeCheckoutSession
     */
    public_key?: string;
    /**
     * Stripe Connected Account Id of the Maker of the Product.
     * @type {string}
     * @memberof StripeCheckoutSession
     */
    account_id?: string;
}
/**
 * If a Product requies subsription and if End User subscribed to the Product.
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * If a Product requies subsription.
     * @type {boolean}
     * @memberof Subscription
     */
    subscription_required?: boolean;
    /**
     * If End User subscribed to the Product.
     * @type {boolean}
     * @memberof Subscription
     */
    subscribed?: boolean;
}
/**
 * Table Tab in Data Tab in Constructor mode. This tab is used to select Data Types, assign Entities. Data is displayed for preview purposes.
 * @export
 * @interface TableConstructor
 */
export interface TableConstructor {
    /**
     * 
     * @type {TableMetadata}
     * @memberof TableConstructor
     */
    table_metadata?: TableMetadata;
    /**
     * List of ColumnMetadata.
     * @type {Array<ColumnMetadata>}
     * @memberof TableConstructor
     */
    column_metadata_list?: Array<ColumnMetadata>;
    /**
     * 
     * @type {ProductFullMetadata}
     * @memberof TableConstructor
     */
    product_full_metadata?: ProductFullMetadata;
    /**
     * 
     * @type {TableFullMetadata}
     * @memberof TableConstructor
     */
    table_full_metadata?: TableFullMetadata;
    /**
     * Actual values when Table display. Outer array is rows, inner array is cells.
     * @type {Array<Array<string>>}
     * @memberof TableConstructor
     */
    value_list_list?: Array<Array<string>>;
    /**
     * List of columns and corresponding list of entity candidates.
     * @type {Array<EntityMetadataCandidateList>}
     * @memberof TableConstructor
     */
    entity_metadata_candidate_list_list?: Array<EntityMetadataCandidateList>;
    /**
     * 
     * @type {UserInfo}
     * @memberof TableConstructor
     */
    user_info?: UserInfo;
}
/**
 * TableMetadata with all Columns.
 * @export
 * @interface TableFullMetadata
 */
export interface TableFullMetadata {
    /**
     * 
     * @type {TableMetadata}
     * @memberof TableFullMetadata
     */
    table_metadata?: TableMetadata;
    /**
     * List of ColumnMetadata of all Columns of the Table.
     * @type {Array<ColumnMetadata>}
     * @memberof TableFullMetadata
     */
    column_metadata_list?: Array<ColumnMetadata>;
}
/**
 * TableMetadata as it is stored in MetadataStore.
 * @export
 * @interface TableMetadata
 */
export interface TableMetadata {
    /**
     * A unique name as referenced by system and in scripts. Subject to regular variable name rules.
     * @type {string}
     * @memberof TableMetadata
     */
    name?: string;
    /**
     * Name of the Product the Table belongs to.
     * @type {string}
     * @memberof TableMetadata
     */
    product_name?: string;
    /**
     * Title as seen by End User if applicable.
     * @type {string}
     * @memberof TableMetadata
     */
    title?: string | null;
    /**
     * Few sentences long description as seen by End User if applicable.
     * @type {string}
     * @memberof TableMetadata
     */
    description?: string | null;
    /**
     * Primary key column name of the Table. Must be consistent with Column\'s is_primary_key field.
     * @type {string}
     * @memberof TableMetadata
     */
    primary_key_column_name?: string | null;
    /**
     * Numeric popularity value. Currentluy not used.
     * @type {number}
     * @memberof TableMetadata
     */
    popularity?: number | null;
    /**
     * 
     * @type {DataSource}
     * @memberof TableMetadata
     */
    data_source?: DataSource;
}
/**
 * Describes how to display a Table.
 * @export
 * @interface TableViewMetadata
 */
export interface TableViewMetadata {
    /**
     * Title as seen by End User. Not attach to a row, but for overall Table.
     * @type {string}
     * @memberof TableViewMetadata
     */
    title?: string | null;
    /**
     * Subtitle as seen by End User. Not attach to a row, but for overall Table.
     * @type {string}
     * @memberof TableViewMetadata
     */
    subtitle?: string | null;
    /**
     * Few sentences long description as seen by End User.
     * @type {string}
     * @memberof TableViewMetadata
     */
    description?: string | null;
    /**
     * Reference to an image to display on top of a Table.
     * @type {string}
     * @memberof TableViewMetadata
     */
    image_url?: string | null;
    /**
     * If End Users are able to navigate to this View from navigation bar.
     * @type {boolean}
     * @memberof TableViewMetadata
     */
    top_level_nav?: boolean | null;
    /**
     * List of references to Columns to display.
     * @type {Array<ColumnViewMetadata>}
     * @memberof TableViewMetadata
     */
    column_view_list?: Array<ColumnViewMetadata> | null;
}
/**
 * User, both Maker and End User stored in database.
 * @export
 * @interface User
 */
export interface User {
    /**
     * Obfusticated User Id.
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * User First Name.
     * @type {string}
     * @memberof User
     */
    first_name?: string;
    /**
     * User Last Name.
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * Name as other Users see it.
     * @type {string}
     * @memberof User
     */
    display_name?: string;
    /**
     * User Email.
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * Salt of User Password.
     * @type {string}
     * @memberof User
     */
    password_salt?: string;
    /**
     * Hash of User Password.
     * @type {string}
     * @memberof User
     */
    password_hash?: string;
}
/**
 * User, both Maker and End User, credentials to sign in.
 * @export
 * @interface UserCredentials
 */
export interface UserCredentials {
    /**
     * User Email.
     * @type {string}
     * @memberof UserCredentials
     */
    email?: string;
    /**
     * Hash of User Password.
     * @type {string}
     * @memberof UserCredentials
     */
    password?: string;
}
/**
 * User, both Maker and End User.
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * User First Name.
     * @type {string}
     * @memberof UserInfo
     */
    first_name?: string;
    /**
     * User Last Name.
     * @type {string}
     * @memberof UserInfo
     */
    last_name?: string;
    /**
     * Name as other Users see it.
     * @type {string}
     * @memberof UserInfo
     */
    display_name?: string;
    /**
     * User Email.
     * @type {string}
     * @memberof UserInfo
     */
    email?: string;
    /**
     * if Stripe Account has been connected to User.
     * @type {boolean}
     * @memberof UserInfo
     */
    stripe_connected?: boolean;
    /**
     * If Stripe Account allows to charge End Users.
     * @type {boolean}
     * @memberof UserInfo
     */
    stripe_charges_enabled?: boolean;
}
/**
 * View Tab in Views Tab in Constructor mode. This tab is used to select displayed Columns, Nested Views, titles, etc. Here Maker constructs what End User will actually see.
 * @export
 * @interface ViewConstructor
 */
export interface ViewConstructor {
    /**
     * 
     * @type {ProductFullMetadata}
     * @memberof ViewConstructor
     */
    product_full_metadata?: ProductFullMetadata;
    /**
     * 
     * @type {ViewMetadata}
     * @memberof ViewConstructor
     */
    view_metadata?: ViewMetadata;
    /**
     * 
     * @type {ViewPage}
     * @memberof ViewConstructor
     */
    preview_view_page?: ViewPage;
    /**
     * 
     * @type {ViewPossibleForView}
     * @memberof ViewConstructor
     */
    view_possible_for_view?: ViewPossibleForView;
    /**
     * 
     * @type {UserInfo}
     * @memberof ViewConstructor
     */
    user_info?: UserInfo;
}
/**
 * Specifies possible and applied filter.
 * @export
 * @interface ViewFilter
 */
export interface ViewFilter {
    /**
     * 
     * @type {IntRangeFilter}
     * @memberof ViewFilter
     */
    int_range_view_filter?: IntRangeFilter;
    /**
     * 
     * @type {FloatRangeFilter}
     * @memberof ViewFilter
     */
    float_range_view_filter?: FloatRangeFilter;
    /**
     * 
     * @type {EnumRangeFilter}
     * @memberof ViewFilter
     */
    enum_view_filter?: EnumRangeFilter;
    /**
     * 
     * @type {BooleanFilter}
     * @memberof ViewFilter
     */
    boolean_view_filter?: BooleanFilter;
    /**
     * 
     * @type {LocationFilter}
     * @memberof ViewFilter
     */
    location_view_filter?: LocationFilter;
    /**
     * 
     * @type {LocationDistanceFilter}
     * @memberof ViewFilter
     */
    location_distance_view_filter?: LocationDistanceFilter;
}
/**
 * Describes how to display data from a Table. It can describe how to display a Table or a Card.
 * @export
 * @interface ViewMetadata
 */
export interface ViewMetadata {
    /**
     * A unique name as referenced by system and in scripts. Subject to regular variable name rules.
     * @type {string}
     * @memberof ViewMetadata
     */
    name?: string;
    /**
     * Product name to display.
     * @type {string}
     * @memberof ViewMetadata
     */
    product_name?: string;
    /**
     * Table name to display.
     * @type {string}
     * @memberof ViewMetadata
     */
    table_name?: string;
    /**
     * Comma-separated list of tags for search and reference by End User.
     * @type {Array<string>}
     * @memberof ViewMetadata
     */
    tag_list?: Array<string> | null;
    /**
     * Numeric popularity value. Currentluy not used.
     * @type {number}
     * @memberof ViewMetadata
     */
    popularity?: number | null;
    /**
     * Type of view. Can be either \'table\' or \'card\'.
     * @type {string}
     * @memberof ViewMetadata
     */
    view_type?: string | null;
    /**
     * 
     * @type {TableViewMetadata}
     * @memberof ViewMetadata
     */
    table_view?: TableViewMetadata;
    /**
     * 
     * @type {CardViewMetadata}
     * @memberof ViewMetadata
     */
    card_view?: CardViewMetadata;
}
/**
 * Data and Metadata for a View. This structure is used to actually display data to End User and also to preview in Construction mode.
 * @export
 * @interface ViewPage
 */
export interface ViewPage {
    /**
     * 
     * @type {ProductFullMetadata}
     * @memberof ViewPage
     */
    product_full_metadata?: ProductFullMetadata;
    /**
     * 
     * @type {ViewMetadata}
     * @memberof ViewPage
     */
    view_metadata?: ViewMetadata;
    /**
     * 
     * @type {TableMetadata}
     * @memberof ViewPage
     */
    table_metadata?: TableMetadata;
    /**
     * List of ColumnMetadata of displayed View. OBSOLETE, Use view_metadata instead.
     * @type {Array<ColumnMetadata>}
     * @memberof ViewPage
     */
    column_metadata_list?: Array<ColumnMetadata>;
    /**
     * Title as seen by End User.
     * @type {string}
     * @memberof ViewPage
     */
    title?: string;
    /**
     * Subtitle as seen by End User.
     * @type {string}
     * @memberof ViewPage
     */
    subtitle?: string;
    /**
     * Few sentences long description as seen by End User.
     * @type {string}
     * @memberof ViewPage
     */
    description?: string;
    /**
     * Reference to an image to display on top of a Table or on left upper corner of a Card.
     * @type {string}
     * @memberof ViewPage
     */
    image_url?: string;
    /**
     * Actual values when Card View is display.
     * @type {Array<string>}
     * @memberof ViewPage
     */
    value_list?: Array<string>;
    /**
     * Actual values when Table View is display. Outer array is rows, inner array is cells.
     * @type {Array<Array<string>>}
     * @memberof ViewPage
     */
    value_list_list?: Array<Array<string>>;
    /**
     * Total number of row count satisfied the filters. Needed for pagination.
     * @type {number}
     * @memberof ViewPage
     */
    total_row_count?: number;
    /**
     * List of Views which End User can navigate from top level navigation bar.
     * @type {Array<ViewMetadata>}
     * @memberof ViewPage
     */
    top_level_nav_view_metadata_list?: Array<ViewMetadata>;
    /**
     * 
     * @type {FilterParams}
     * @memberof ViewPage
     */
    filter_params?: FilterParams;
    /**
     * List of data and metadata of Nested Views.
     * @type {Array<NestedViewPage>}
     * @memberof ViewPage
     */
    nested_views?: Array<NestedViewPage>;
    /**
     * 
     * @type {Subscription}
     * @memberof ViewPage
     */
    subscription?: Subscription;
    /**
     * 
     * @type {UserInfo}
     * @memberof ViewPage
     */
    user_info?: UserInfo;
}
/**
 * Specifies all params to display a View.
 * @export
 * @interface ViewParams
 */
export interface ViewParams {
    /**
     * 
     * @type {FilterParams}
     * @memberof ViewParams
     */
    filter_params?: FilterParams;
    /**
     * 
     * @type {DisplayParams}
     * @memberof ViewParams
     */
    display_params?: DisplayParams;
}
/**
 * A possible column to add to a View.
 * @export
 * @interface ViewPossibleColumn
 */
export interface ViewPossibleColumn {
    /**
     * Product name to display.
     * @type {string}
     * @memberof ViewPossibleColumn
     */
    product_name?: string;
    /**
     * Taable name to display.
     * @type {string}
     * @memberof ViewPossibleColumn
     */
    table_name?: string;
    /**
     * Column name to display.
     * @type {string}
     * @memberof ViewPossibleColumn
     */
    column_name?: string;
    /**
     * Title as seen by End User if applicable.
     * @type {string}
     * @memberof ViewPossibleColumn
     */
    title?: string;
    /**
     * Name of actual Entity currently assigned to this column.
     * @type {string}
     * @memberof ViewPossibleColumn
     */
    entity_name?: string;
    /**
     * 
     * @type {Array<ViewPossibleView>}
     * @memberof ViewPossibleColumn
     */
    possible_on_click_list?: Array<ViewPossibleView>;
}
/**
 * All possible columns, additional products and Nested Views.
 * @export
 * @interface ViewPossibleForView
 */
export interface ViewPossibleForView {
    /**
     * List of possible Columns to add to the View.
     * @type {Array<ViewPossibleColumn>}
     * @memberof ViewPossibleForView
     */
    possible_column_list?: Array<ViewPossibleColumn>;
    /**
     * List of possible additional products and their tables to add to the view.
     * @type {Array<ViewPossibleProductTable>}
     * @memberof ViewPossibleForView
     */
    possible_additional_product_table_list?: Array<ViewPossibleProductTable>;
    /**
     * List of possible products and their Nested Views to add to the view.
     * @type {Array<ViewPossibleProductView>}
     * @memberof ViewPossibleForView
     */
    possible_product_nested_view_list?: Array<ViewPossibleProductView>;
}
/**
 * A possible additional product and its tables to add to a view.
 * @export
 * @interface ViewPossibleProductTable
 */
export interface ViewPossibleProductTable {
    /**
     * 
     * @type {ProductMetadata}
     * @memberof ViewPossibleProductTable
     */
    product_metadata?: ProductMetadata;
    /**
     * List of possible additional tables to add to the view.
     * @type {Array<ViewPossibleTable>}
     * @memberof ViewPossibleProductTable
     */
    possible_table_list?: Array<ViewPossibleTable>;
}
/**
 * A possible product and its Nested Views to add to a view.
 * @export
 * @interface ViewPossibleProductView
 */
export interface ViewPossibleProductView {
    /**
     * 
     * @type {ProductMetadata}
     * @memberof ViewPossibleProductView
     */
    product_metadata?: ProductMetadata;
    /**
     * List of possible Nested Views to add to the view.
     * @type {Array<ViewPossibleView>}
     * @memberof ViewPossibleProductView
     */
    possible_view_list?: Array<ViewPossibleView>;
}
/**
 * A possible additional table with additional product to add to a View.
 * @export
 * @interface ViewPossibleTable
 */
export interface ViewPossibleTable {
    /**
     * 
     * @type {TableMetadata}
     * @memberof ViewPossibleTable
     */
    table_metadata?: TableMetadata;
    /**
     * List of possible Columns to add to the View.
     * @type {Array<ViewPossibleColumn>}
     * @memberof ViewPossibleTable
     */
    possible_column_list?: Array<ViewPossibleColumn>;
    /**
     * Column Name in original displayed Table which is used to connect to this additional table.
     * @type {string}
     * @memberof ViewPossibleTable
     */
    column_name_from?: string;
    /**
     * Column Name in additional table which is used to connect to original displayed Table.
     * @type {string}
     * @memberof ViewPossibleTable
     */
    column_name_to?: string;
}
/**
 * A possible Nested View with additional product view to add to a view.
 * @export
 * @interface ViewPossibleView
 */
export interface ViewPossibleView {
    /**
     * 
     * @type {ViewMetadata}
     * @memberof ViewPossibleView
     */
    view_metadata?: ViewMetadata;
    /**
     * Column Name in original displayed Table which is used to connect to this Nested View.
     * @type {string}
     * @memberof ViewPossibleView
     */
    column_name_from?: string;
    /**
     * Column Name in Nested View which is used to connect to original displayed Table.
     * @type {string}
     * @memberof ViewPossibleView
     */
    column_name_to?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This call is made when Maker adds a new Table to their Product and uploads a file. File can be provided by either uploading using /upload_file call and providing filename or by providing file_link to publicly available file. Backend reads file, adds data to DataStore, if applicable, adds Views and returns a TableConstructor with Table metadata and Preview data. Frontend should display this new Table in \'Data\' tab.
         * @summary Add new Table by uploadig file.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} tableName 
         * @param {string} addDefaultViews 
         * @param {string} [filename] 
         * @param {string} [fileLink] 
         * @param {DataSource} [dataSource] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTableUploadFilePost: async (sessionId: string, productName: string, tableName: string, addDefaultViews: string, filename?: string, fileLink?: string, dataSource?: DataSource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling addTableUploadFilePost.');
            }
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling addTableUploadFilePost.');
            }
            // verify required parameter 'tableName' is not null or undefined
            if (tableName === null || tableName === undefined) {
                throw new RequiredError('tableName','Required parameter tableName was null or undefined when calling addTableUploadFilePost.');
            }
            // verify required parameter 'addDefaultViews' is not null or undefined
            if (addDefaultViews === null || addDefaultViews === undefined) {
                throw new RequiredError('addDefaultViews','Required parameter addDefaultViews was null or undefined when calling addTableUploadFilePost.');
            }
            const localVarPath = `/add_table_upload_file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }

            if (tableName !== undefined) {
                localVarQueryParameter['table_name'] = tableName;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (fileLink !== undefined) {
                localVarQueryParameter['file_link'] = fileLink;
            }

            if (addDefaultViews !== undefined) {
                localVarQueryParameter['add_default_views'] = addDefaultViews;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof dataSource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(dataSource !== undefined ? dataSource : {})
                : (dataSource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add test and demo accounts and data products. INTERNAL ONLY.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTestDataPost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/add_test_data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when Maker adds a new View to their Product. Frontend sends Table name which new View should display and mode (Table or Card). Backend adds new View and returns a ViewConstructor with View metadata and Preview data. Frontend should display this new View in \'View\' tab.
         * @summary Add new View.
         * @param {string} sessionId 
         * @param {ViewMetadata} [viewMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addViewPost: async (sessionId: string, viewMetadata?: ViewMetadata, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling addViewPost.');
            }
            const localVarPath = `/add_view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof viewMetadata !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(viewMetadata !== undefined ? viewMetadata : {})
                : (viewMetadata || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels a Stripe Subscription for all End User to given Product.
         * @param {string} productName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelStripeAllProductSubscriptionPost: async (productName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling cancelStripeAllProductSubscriptionPost.');
            }
            const localVarPath = `/cancel_stripe_all_product_subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancels a Stripe Subscription for current End User to given Product.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelStripeSubscriptionPost: async (sessionId: string, productName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling cancelStripeSubscriptionPost.');
            }
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling cancelStripeSubscriptionPost.');
            }
            const localVarPath = `/cancel_stripe_subscription`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when Maker creates a new Product and uploads a file. File can be provided by either uploading using /upload_file call and providing filename or by providing file_link to publicly available file. Backend reads file, adds data to DataStore, if applicable, adds Views and returns a ProductConstructor. Frontend should switch immidietely to \'Publish\' tab and display ProductConstructor.
         * @summary Create Product by uploadig file.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} tableName 
         * @param {string} addDefaultViews 
         * @param {string} [filename] 
         * @param {string} [fileLink] 
         * @param {DataSource} [dataSource] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductUploadFilePost: async (sessionId: string, productName: string, tableName: string, addDefaultViews: string, filename?: string, fileLink?: string, dataSource?: DataSource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling createProductUploadFilePost.');
            }
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling createProductUploadFilePost.');
            }
            // verify required parameter 'tableName' is not null or undefined
            if (tableName === null || tableName === undefined) {
                throw new RequiredError('tableName','Required parameter tableName was null or undefined when calling createProductUploadFilePost.');
            }
            // verify required parameter 'addDefaultViews' is not null or undefined
            if (addDefaultViews === null || addDefaultViews === undefined) {
                throw new RequiredError('addDefaultViews','Required parameter addDefaultViews was null or undefined when calling createProductUploadFilePost.');
            }
            const localVarPath = `/create_product_upload_file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }

            if (tableName !== undefined) {
                localVarQueryParameter['table_name'] = tableName;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (fileLink !== undefined) {
                localVarQueryParameter['file_link'] = fileLink;
            }

            if (addDefaultViews !== undefined) {
                localVarQueryParameter['add_default_views'] = addDefaultViews;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof dataSource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(dataSource !== undefined ? dataSource : {})
                : (dataSource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets file from Backend file storage.
         * @param {string} category Category of file, possible values are \&#39;image\&#39;, \&#39;data\&#39;.
         * @param {string} filename Filename as returned by /upload_file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileGet: async (category: string, filename: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            if (category === null || category === undefined) {
                throw new RequiredError('category','Required parameter category was null or undefined when calling getFileGet.');
            }
            // verify required parameter 'filename' is not null or undefined
            if (filename === null || filename === undefined) {
                throw new RequiredError('filename','Required parameter filename was null or undefined when calling getFileGet.');
            }
            const localVarPath = `/get_file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when Maker selects their product from their list. Backend returns a ProductConstructor and Frontend should switch immidietely \'Publish\' tab where ProductConstructor is displayed.
         * @summary Get ProductConsructor.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductConstructorGet: async (sessionId: string, productName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling getProductConstructorGet.');
            }
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling getProductConstructorGet.');
            }
            const localVarPath = `/get_product_constructor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when Maker click on \'My Data Products\'. Frontend should display list of those Product for Maker to select one.
         * @summary Get list of Products for current Maker.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductListPageGet: async (sessionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling getProductListPageGet.');
            }
            const localVarPath = `/get_product_list_page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when End User visits a home page of a Product. This is how End User starts navigating the Product.
         * @summary Get Product home page View as seen by End User.
         * @param {string} productName 
         * @param {string} [sessionId] 
         * @param {DisplayParams} [displayParams] Params to display a View.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductPost: async (productName: string, sessionId?: string, displayParams?: DisplayParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling getProductPost.');
            }
            const localVarPath = `/get_product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof displayParams !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(displayParams !== undefined ? displayParams : {})
                : (displayParams || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when Maker click on \'My Data Products\'. Frontend should display list of those Product for Maker to select one.
         * @summary Get list of Products for current Maker. OBSOLETE. Use /get_product_list_page instead.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsGet: async (sessionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling getProductsGet.');
            }
            const localVarPath = `/get_products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates and returns a URL to redirect to to connect a Maker to their Stripe account.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeAccountLinkPost: async (sessionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling getStripeAccountLinkPost.');
            }
            const localVarPath = `/get_stripe_account_link`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates and returns Stripe Checkout Session for an End User to subscribe for a Product.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeCheckoutSessionPost: async (sessionId: string, productName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling getStripeCheckoutSessionPost.');
            }
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling getStripeCheckoutSessionPost.');
            }
            const localVarPath = `/get_stripe_checkout_session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when Maker click on \'Data\' tab on one of tables. Backend sends back hard coded example. Backend sends back TableConstructor which contain Table metadata and Preview data to be displayed.
         * @summary Get TableConsructor example.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableConstructorExampleGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/get_table_constructor_example`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when Maker click on \'Data\' tab on one of tables. Frontend sends request Product and Table. Backend sends back TableConstructor which contain Table metadata and Preview data to be displayed.
         * @summary Get TableConsructor.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableConstructorGet: async (sessionId: string, productName: string, tableName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling getTableConstructorGet.');
            }
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling getTableConstructorGet.');
            }
            // verify required parameter 'tableName' is not null or undefined
            if (tableName === null || tableName === undefined) {
                throw new RequiredError('tableName','Required parameter tableName was null or undefined when calling getTableConstructorGet.');
            }
            const localVarPath = `/get_table_constructor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }

            if (tableName !== undefined) {
                localVarQueryParameter['table_name'] = tableName;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when Maker click on \'View\' tab on one of Views. Frontend sends request Product and View. Backend sends back ViewConstructor which contain View Table metadata and Preview View to be displayed. Preview View should not be interactive.
         * @summary Get ViewConsructor.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} viewName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewConstructorGet: async (sessionId: string, productName: string, viewName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling getViewConstructorGet.');
            }
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling getViewConstructorGet.');
            }
            // verify required parameter 'viewName' is not null or undefined
            if (viewName === null || viewName === undefined) {
                throw new RequiredError('viewName','Required parameter viewName was null or undefined when calling getViewConstructorGet.');
            }
            const localVarPath = `/get_view_constructor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }

            if (viewName !== undefined) {
                localVarQueryParameter['view_name'] = viewName;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when End User navigates a Product. When End User navigates to a Card View, a value and, optionally, column_name should be sent.
         * @summary Get View as seen by End User.
         * @param {string} productName 
         * @param {string} viewName 
         * @param {string} [sessionId] 
         * @param {string} [columnName] If row queried not by primary key, specify column name.
         * @param {string} [value] Value of primary key or specified column.
         * @param {ViewParams} [viewParams] Params to display a View.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewPost: async (productName: string, viewName: string, sessionId?: string, columnName?: string, value?: string, viewParams?: ViewParams, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling getViewPost.');
            }
            // verify required parameter 'viewName' is not null or undefined
            if (viewName === null || viewName === undefined) {
                throw new RequiredError('viewName','Required parameter viewName was null or undefined when calling getViewPost.');
            }
            const localVarPath = `/get_view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }

            if (viewName !== undefined) {
                localVarQueryParameter['view_name'] = viewName;
            }

            if (columnName !== undefined) {
                localVarQueryParameter['column_name'] = columnName;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof viewParams !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(viewParams !== undefined ? viewParams : {})
                : (viewParams || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initializes server. Adds built-in entites and various data. INTERNAL ONLY.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializePost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/initialize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Allows to ping Server to make sure it\'s running. INTERNAL ONLY.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made to publish or unpublish Product.
         * @summary Add or updates ProductMetadata.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} published 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishProductPost: async (sessionId: string, productName: string, published: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling publishProductPost.');
            }
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling publishProductPost.');
            }
            // verify required parameter 'published' is not null or undefined
            if (published === null || published === undefined) {
                throw new RequiredError('published','Required parameter published was null or undefined when calling publishProductPost.');
            }
            const localVarPath = `/publish_product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }

            if (published !== undefined) {
                localVarQueryParameter['published'] = published;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Refresh all stores and drops all the data. INTERNAL ONLY.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshStoresPost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/refresh_stores`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign In User and return their new session_id
         * @param {UserCredentials} [userCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInPost: async (userCredentials?: UserCredentials, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/sign_in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userCredentials !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userCredentials !== undefined ? userCredentials : {})
                : (userCredentials || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sign Up User and return their new session_id
         * @param {NewUser} [newUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpPost: async (newUser?: NewUser, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/sign_up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof newUser !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(newUser !== undefined ? newUser : {})
                : (newUser || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary HTML page when a Maker finishes connecting Stripe account. INTERNAL ONLY.
         * @param {string} userAccountId 
         * @param {string} userAccountEmail 
         * @param {string} stripeAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeAccountLinkRefreshGet: async (userAccountId: string, userAccountEmail: string, stripeAccountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAccountId' is not null or undefined
            if (userAccountId === null || userAccountId === undefined) {
                throw new RequiredError('userAccountId','Required parameter userAccountId was null or undefined when calling stripeAccountLinkRefreshGet.');
            }
            // verify required parameter 'userAccountEmail' is not null or undefined
            if (userAccountEmail === null || userAccountEmail === undefined) {
                throw new RequiredError('userAccountEmail','Required parameter userAccountEmail was null or undefined when calling stripeAccountLinkRefreshGet.');
            }
            // verify required parameter 'stripeAccountId' is not null or undefined
            if (stripeAccountId === null || stripeAccountId === undefined) {
                throw new RequiredError('stripeAccountId','Required parameter stripeAccountId was null or undefined when calling stripeAccountLinkRefreshGet.');
            }
            const localVarPath = `/stripe_account_link_refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userAccountId !== undefined) {
                localVarQueryParameter['user_account_id'] = userAccountId;
            }

            if (userAccountEmail !== undefined) {
                localVarQueryParameter['user_account_email'] = userAccountEmail;
            }

            if (stripeAccountId !== undefined) {
                localVarQueryParameter['stripe_account_id'] = stripeAccountId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary HTML page when a Maker doesn\'t finish connecting Stripe account. INTERNAL ONLY.
         * @param {string} userAccountId 
         * @param {string} userAccountEmail 
         * @param {string} stripeAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeAccountLinkReturnGet: async (userAccountId: string, userAccountEmail: string, stripeAccountId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAccountId' is not null or undefined
            if (userAccountId === null || userAccountId === undefined) {
                throw new RequiredError('userAccountId','Required parameter userAccountId was null or undefined when calling stripeAccountLinkReturnGet.');
            }
            // verify required parameter 'userAccountEmail' is not null or undefined
            if (userAccountEmail === null || userAccountEmail === undefined) {
                throw new RequiredError('userAccountEmail','Required parameter userAccountEmail was null or undefined when calling stripeAccountLinkReturnGet.');
            }
            // verify required parameter 'stripeAccountId' is not null or undefined
            if (stripeAccountId === null || stripeAccountId === undefined) {
                throw new RequiredError('stripeAccountId','Required parameter stripeAccountId was null or undefined when calling stripeAccountLinkReturnGet.');
            }
            const localVarPath = `/stripe_account_link_return`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userAccountId !== undefined) {
                localVarQueryParameter['user_account_id'] = userAccountId;
            }

            if (userAccountEmail !== undefined) {
                localVarQueryParameter['user_account_email'] = userAccountEmail;
            }

            if (stripeAccountId !== undefined) {
                localVarQueryParameter['stripe_account_id'] = stripeAccountId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary HTML page when an End User does not finish checkout process. INTERNAL ONLY.
         * @param {string} userAccountId 
         * @param {string} stripeAccountId 
         * @param {string} productName 
         * @param {string} stripeProductId 
         * @param {string} stripePriceId 
         * @param {string} userCustomerId 
         * @param {string} userCustomerEmail 
         * @param {string} stripeCustomerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeCheckoutSessionCancelGet: async (userAccountId: string, stripeAccountId: string, productName: string, stripeProductId: string, stripePriceId: string, userCustomerId: string, userCustomerEmail: string, stripeCustomerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAccountId' is not null or undefined
            if (userAccountId === null || userAccountId === undefined) {
                throw new RequiredError('userAccountId','Required parameter userAccountId was null or undefined when calling stripeCheckoutSessionCancelGet.');
            }
            // verify required parameter 'stripeAccountId' is not null or undefined
            if (stripeAccountId === null || stripeAccountId === undefined) {
                throw new RequiredError('stripeAccountId','Required parameter stripeAccountId was null or undefined when calling stripeCheckoutSessionCancelGet.');
            }
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling stripeCheckoutSessionCancelGet.');
            }
            // verify required parameter 'stripeProductId' is not null or undefined
            if (stripeProductId === null || stripeProductId === undefined) {
                throw new RequiredError('stripeProductId','Required parameter stripeProductId was null or undefined when calling stripeCheckoutSessionCancelGet.');
            }
            // verify required parameter 'stripePriceId' is not null or undefined
            if (stripePriceId === null || stripePriceId === undefined) {
                throw new RequiredError('stripePriceId','Required parameter stripePriceId was null or undefined when calling stripeCheckoutSessionCancelGet.');
            }
            // verify required parameter 'userCustomerId' is not null or undefined
            if (userCustomerId === null || userCustomerId === undefined) {
                throw new RequiredError('userCustomerId','Required parameter userCustomerId was null or undefined when calling stripeCheckoutSessionCancelGet.');
            }
            // verify required parameter 'userCustomerEmail' is not null or undefined
            if (userCustomerEmail === null || userCustomerEmail === undefined) {
                throw new RequiredError('userCustomerEmail','Required parameter userCustomerEmail was null or undefined when calling stripeCheckoutSessionCancelGet.');
            }
            // verify required parameter 'stripeCustomerId' is not null or undefined
            if (stripeCustomerId === null || stripeCustomerId === undefined) {
                throw new RequiredError('stripeCustomerId','Required parameter stripeCustomerId was null or undefined when calling stripeCheckoutSessionCancelGet.');
            }
            const localVarPath = `/stripe_checkout_session_cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userAccountId !== undefined) {
                localVarQueryParameter['user_account_id'] = userAccountId;
            }

            if (stripeAccountId !== undefined) {
                localVarQueryParameter['stripe_account_id'] = stripeAccountId;
            }

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }

            if (stripeProductId !== undefined) {
                localVarQueryParameter['stripe_product_id'] = stripeProductId;
            }

            if (stripePriceId !== undefined) {
                localVarQueryParameter['stripe_price_id'] = stripePriceId;
            }

            if (userCustomerId !== undefined) {
                localVarQueryParameter['user_customer_id'] = userCustomerId;
            }

            if (userCustomerEmail !== undefined) {
                localVarQueryParameter['user_customer_email'] = userCustomerEmail;
            }

            if (stripeCustomerId !== undefined) {
                localVarQueryParameter['stripe_customer_id'] = stripeCustomerId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary HTML page when an End User successfully finishes Checkout process. INTERNAL ONLY.
         * @param {string} checkoutSessionId 
         * @param {string} userAccountId 
         * @param {string} stripeAccountId 
         * @param {string} productName 
         * @param {string} stripeProductId 
         * @param {string} stripePriceId 
         * @param {string} userCustomerId 
         * @param {string} userCustomerEmail 
         * @param {string} stripeCustomerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeCheckoutSessionSuccessGet: async (checkoutSessionId: string, userAccountId: string, stripeAccountId: string, productName: string, stripeProductId: string, stripePriceId: string, userCustomerId: string, userCustomerEmail: string, stripeCustomerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutSessionId' is not null or undefined
            if (checkoutSessionId === null || checkoutSessionId === undefined) {
                throw new RequiredError('checkoutSessionId','Required parameter checkoutSessionId was null or undefined when calling stripeCheckoutSessionSuccessGet.');
            }
            // verify required parameter 'userAccountId' is not null or undefined
            if (userAccountId === null || userAccountId === undefined) {
                throw new RequiredError('userAccountId','Required parameter userAccountId was null or undefined when calling stripeCheckoutSessionSuccessGet.');
            }
            // verify required parameter 'stripeAccountId' is not null or undefined
            if (stripeAccountId === null || stripeAccountId === undefined) {
                throw new RequiredError('stripeAccountId','Required parameter stripeAccountId was null or undefined when calling stripeCheckoutSessionSuccessGet.');
            }
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling stripeCheckoutSessionSuccessGet.');
            }
            // verify required parameter 'stripeProductId' is not null or undefined
            if (stripeProductId === null || stripeProductId === undefined) {
                throw new RequiredError('stripeProductId','Required parameter stripeProductId was null or undefined when calling stripeCheckoutSessionSuccessGet.');
            }
            // verify required parameter 'stripePriceId' is not null or undefined
            if (stripePriceId === null || stripePriceId === undefined) {
                throw new RequiredError('stripePriceId','Required parameter stripePriceId was null or undefined when calling stripeCheckoutSessionSuccessGet.');
            }
            // verify required parameter 'userCustomerId' is not null or undefined
            if (userCustomerId === null || userCustomerId === undefined) {
                throw new RequiredError('userCustomerId','Required parameter userCustomerId was null or undefined when calling stripeCheckoutSessionSuccessGet.');
            }
            // verify required parameter 'userCustomerEmail' is not null or undefined
            if (userCustomerEmail === null || userCustomerEmail === undefined) {
                throw new RequiredError('userCustomerEmail','Required parameter userCustomerEmail was null or undefined when calling stripeCheckoutSessionSuccessGet.');
            }
            // verify required parameter 'stripeCustomerId' is not null or undefined
            if (stripeCustomerId === null || stripeCustomerId === undefined) {
                throw new RequiredError('stripeCustomerId','Required parameter stripeCustomerId was null or undefined when calling stripeCheckoutSessionSuccessGet.');
            }
            const localVarPath = `/stripe_checkout_session_success`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (checkoutSessionId !== undefined) {
                localVarQueryParameter['checkout_session_id'] = checkoutSessionId;
            }

            if (userAccountId !== undefined) {
                localVarQueryParameter['user_account_id'] = userAccountId;
            }

            if (stripeAccountId !== undefined) {
                localVarQueryParameter['stripe_account_id'] = stripeAccountId;
            }

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }

            if (stripeProductId !== undefined) {
                localVarQueryParameter['stripe_product_id'] = stripeProductId;
            }

            if (stripePriceId !== undefined) {
                localVarQueryParameter['stripe_price_id'] = stripePriceId;
            }

            if (userCustomerId !== undefined) {
                localVarQueryParameter['user_customer_id'] = userCustomerId;
            }

            if (userCustomerEmail !== undefined) {
                localVarQueryParameter['user_customer_email'] = userCustomerEmail;
            }

            if (stripeCustomerId !== undefined) {
                localVarQueryParameter['stripe_customer_id'] = stripeCustomerId;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload file to Backend file storage.
         * @param {string} category Category of file, possible values are \&#39;image\&#39;, \&#39;data\&#39;.
         * @param {string} [publicLink] If provide permanent public link to file.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilePost: async (category: string, publicLink?: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'category' is not null or undefined
            if (category === null || category === undefined) {
                throw new RequiredError('category','Required parameter category was null or undefined when calling uploadFilePost.');
            }
            const localVarPath = `/upload_file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (publicLink !== undefined) {
                localVarQueryParameter['public_link'] = publicLink;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when Maker on \'Data\' tab add a new Entity. Frontend sends EntityFullMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates Entity.
         * @param {EntityFullMetadata} [entityFullMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertEntityMetadataPost: async (entityFullMetadata?: EntityFullMetadata, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/upsert_entity_metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof entityFullMetadata !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(entityFullMetadata !== undefined ? entityFullMetadata : {})
                : (entityFullMetadata || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when Maker on \'Publish\' tab makes changes to Product as a whole. Frontend sends ProductMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates ProductMetadata.
         * @param {string} sessionId 
         * @param {ProductMetadata} [productMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertProductMetadataPost: async (sessionId: string, productMetadata?: ProductMetadata, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling upsertProductMetadataPost.');
            }
            const localVarPath = `/upsert_product_metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof productMetadata !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(productMetadata !== undefined ? productMetadata : {})
                : (productMetadata || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when Maker on \'Publish\' tab makes changes to Product as a whole. It also has a parameter to publish or unpublish Product. Frontend sends ProductMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates ProductMetadata.
         * @param {string} sessionId 
         * @param {string} published 
         * @param {ProductMetadata} [productMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertPublishProductMetadataPost: async (sessionId: string, published: string, productMetadata?: ProductMetadata, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling upsertPublishProductMetadataPost.');
            }
            // verify required parameter 'published' is not null or undefined
            if (published === null || published === undefined) {
                throw new RequiredError('published','Required parameter published was null or undefined when calling upsertPublishProductMetadataPost.');
            }
            const localVarPath = `/upsert_publish_product_metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (published !== undefined) {
                localVarQueryParameter['published'] = published;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof productMetadata !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(productMetadata !== undefined ? productMetadata : {})
                : (productMetadata || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a Stripe Product for Connected Account to be able to subscribe.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {number} price 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertStripeProductPost: async (sessionId: string, productName: string, price: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling upsertStripeProductPost.');
            }
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling upsertStripeProductPost.');
            }
            // verify required parameter 'price' is not null or undefined
            if (price === null || price === undefined) {
                throw new RequiredError('price','Required parameter price was null or undefined when calling upsertStripeProductPost.');
            }
            const localVarPath = `/upsert_stripe_product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }

            if (price !== undefined) {
                localVarQueryParameter['price'] = price;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when Maker on \'Data\' tab makes changes to a Table. Frontend sends TableFullMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates TableMetadata with all Columns.
         * @param {string} sessionId 
         * @param {TableFullMetadata} [tableFullMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertTableMetadataPost: async (sessionId: string, tableFullMetadata?: TableFullMetadata, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling upsertTableMetadataPost.');
            }
            const localVarPath = `/upsert_table_metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof tableFullMetadata !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(tableFullMetadata !== undefined ? tableFullMetadata : {})
                : (tableFullMetadata || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when Maker refreshes data in existing Table in their Product and uploads a file. File can be provided by either uploading using /upload_file call and providing filename or by providing file_link to publicly available file. Backend reads file, refreshes data in DataStore and returns a TableConstructor with data and metadata. Frontend should display refreshed Table in \'Data\' tab. In reality only data is refreshed and metadata is remained the same.
         * @summary Refresh table by uploadig file.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} tableName 
         * @param {string} [filename] 
         * @param {string} [fileLink] 
         * @param {DataSource} [dataSource] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertTableUploadFilePost: async (sessionId: string, productName: string, tableName: string, filename?: string, fileLink?: string, dataSource?: DataSource, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling upsertTableUploadFilePost.');
            }
            // verify required parameter 'productName' is not null or undefined
            if (productName === null || productName === undefined) {
                throw new RequiredError('productName','Required parameter productName was null or undefined when calling upsertTableUploadFilePost.');
            }
            // verify required parameter 'tableName' is not null or undefined
            if (tableName === null || tableName === undefined) {
                throw new RequiredError('tableName','Required parameter tableName was null or undefined when calling upsertTableUploadFilePost.');
            }
            const localVarPath = `/upsert_table_upload_file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }

            if (productName !== undefined) {
                localVarQueryParameter['product_name'] = productName;
            }

            if (tableName !== undefined) {
                localVarQueryParameter['table_name'] = tableName;
            }

            if (filename !== undefined) {
                localVarQueryParameter['filename'] = filename;
            }

            if (fileLink !== undefined) {
                localVarQueryParameter['file_link'] = fileLink;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof dataSource !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(dataSource !== undefined ? dataSource : {})
                : (dataSource || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This call is made when Maker on \'View\' tab makes changes to a View. Frontend sends ViewMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates ViewMetadata.
         * @param {string} sessionId 
         * @param {ViewMetadata} [viewMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertViewMetadataPost: async (sessionId: string, viewMetadata?: ViewMetadata, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            if (sessionId === null || sessionId === undefined) {
                throw new RequiredError('sessionId','Required parameter sessionId was null or undefined when calling upsertViewMetadataPost.');
            }
            const localVarPath = `/upsert_view_metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sessionId !== undefined) {
                localVarQueryParameter['session_id'] = sessionId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof viewMetadata !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(viewMetadata !== undefined ? viewMetadata : {})
                : (viewMetadata || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This call is made when Maker adds a new Table to their Product and uploads a file. File can be provided by either uploading using /upload_file call and providing filename or by providing file_link to publicly available file. Backend reads file, adds data to DataStore, if applicable, adds Views and returns a TableConstructor with Table metadata and Preview data. Frontend should display this new Table in \'Data\' tab.
         * @summary Add new Table by uploadig file.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} tableName 
         * @param {string} addDefaultViews 
         * @param {string} [filename] 
         * @param {string} [fileLink] 
         * @param {DataSource} [dataSource] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTableUploadFilePost(sessionId: string, productName: string, tableName: string, addDefaultViews: string, filename?: string, fileLink?: string, dataSource?: DataSource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableConstructor>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).addTableUploadFilePost(sessionId, productName, tableName, addDefaultViews, filename, fileLink, dataSource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Add test and demo accounts and data products. INTERNAL ONLY.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTestDataPost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).addTestDataPost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when Maker adds a new View to their Product. Frontend sends Table name which new View should display and mode (Table or Card). Backend adds new View and returns a ViewConstructor with View metadata and Preview data. Frontend should display this new View in \'View\' tab.
         * @summary Add new View.
         * @param {string} sessionId 
         * @param {ViewMetadata} [viewMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addViewPost(sessionId: string, viewMetadata?: ViewMetadata, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewConstructor>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).addViewPost(sessionId, viewMetadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Cancels a Stripe Subscription for all End User to given Product.
         * @param {string} productName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelStripeAllProductSubscriptionPost(productName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).cancelStripeAllProductSubscriptionPost(productName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Cancels a Stripe Subscription for current End User to given Product.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelStripeSubscriptionPost(sessionId: string, productName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).cancelStripeSubscriptionPost(sessionId, productName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when Maker creates a new Product and uploads a file. File can be provided by either uploading using /upload_file call and providing filename or by providing file_link to publicly available file. Backend reads file, adds data to DataStore, if applicable, adds Views and returns a ProductConstructor. Frontend should switch immidietely to \'Publish\' tab and display ProductConstructor.
         * @summary Create Product by uploadig file.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} tableName 
         * @param {string} addDefaultViews 
         * @param {string} [filename] 
         * @param {string} [fileLink] 
         * @param {DataSource} [dataSource] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProductUploadFilePost(sessionId: string, productName: string, tableName: string, addDefaultViews: string, filename?: string, fileLink?: string, dataSource?: DataSource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductConstructor>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).createProductUploadFilePost(sessionId, productName, tableName, addDefaultViews, filename, fileLink, dataSource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Gets file from Backend file storage.
         * @param {string} category Category of file, possible values are \&#39;image\&#39;, \&#39;data\&#39;.
         * @param {string} filename Filename as returned by /upload_file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileGet(category: string, filename: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getFileGet(category, filename, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when Maker selects their product from their list. Backend returns a ProductConstructor and Frontend should switch immidietely \'Publish\' tab where ProductConstructor is displayed.
         * @summary Get ProductConsructor.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductConstructorGet(sessionId: string, productName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductConstructor>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getProductConstructorGet(sessionId, productName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when Maker click on \'My Data Products\'. Frontend should display list of those Product for Maker to select one.
         * @summary Get list of Products for current Maker.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductListPageGet(sessionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductListPage>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getProductListPageGet(sessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when End User visits a home page of a Product. This is how End User starts navigating the Product.
         * @summary Get Product home page View as seen by End User.
         * @param {string} productName 
         * @param {string} [sessionId] 
         * @param {DisplayParams} [displayParams] Params to display a View.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductPost(productName: string, sessionId?: string, displayParams?: DisplayParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewPage>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getProductPost(productName, sessionId, displayParams, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when Maker click on \'My Data Products\'. Frontend should display list of those Product for Maker to select one.
         * @summary Get list of Products for current Maker. OBSOLETE. Use /get_product_list_page instead.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductsGet(sessionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductMetadataList>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getProductsGet(sessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates and returns a URL to redirect to to connect a Maker to their Stripe account.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStripeAccountLinkPost(sessionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeAccountLink>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getStripeAccountLinkPost(sessionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates and returns Stripe Checkout Session for an End User to subscribe for a Product.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStripeCheckoutSessionPost(sessionId: string, productName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StripeCheckoutSession>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getStripeCheckoutSessionPost(sessionId, productName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when Maker click on \'Data\' tab on one of tables. Backend sends back hard coded example. Backend sends back TableConstructor which contain Table metadata and Preview data to be displayed.
         * @summary Get TableConsructor example.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTableConstructorExampleGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableConstructor>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getTableConstructorExampleGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when Maker click on \'Data\' tab on one of tables. Frontend sends request Product and Table. Backend sends back TableConstructor which contain Table metadata and Preview data to be displayed.
         * @summary Get TableConsructor.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTableConstructorGet(sessionId: string, productName: string, tableName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableConstructor>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getTableConstructorGet(sessionId, productName, tableName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when Maker click on \'View\' tab on one of Views. Frontend sends request Product and View. Backend sends back ViewConstructor which contain View Table metadata and Preview View to be displayed. Preview View should not be interactive.
         * @summary Get ViewConsructor.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} viewName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewConstructorGet(sessionId: string, productName: string, viewName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewConstructor>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getViewConstructorGet(sessionId, productName, viewName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when End User navigates a Product. When End User navigates to a Card View, a value and, optionally, column_name should be sent.
         * @summary Get View as seen by End User.
         * @param {string} productName 
         * @param {string} viewName 
         * @param {string} [sessionId] 
         * @param {string} [columnName] If row queried not by primary key, specify column name.
         * @param {string} [value] Value of primary key or specified column.
         * @param {ViewParams} [viewParams] Params to display a View.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getViewPost(productName: string, viewName: string, sessionId?: string, columnName?: string, value?: string, viewParams?: ViewParams, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewPage>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getViewPost(productName, viewName, sessionId, columnName, value, viewParams, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Initializes server. Adds built-in entites and various data. INTERNAL ONLY.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initializePost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).initializePost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Allows to ping Server to make sure it\'s running. INTERNAL ONLY.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pingGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).pingGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made to publish or unpublish Product.
         * @summary Add or updates ProductMetadata.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} published 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishProductPost(sessionId: string, productName: string, published: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductMetadata>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).publishProductPost(sessionId, productName, published, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Refresh all stores and drops all the data. INTERNAL ONLY.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshStoresPost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).refreshStoresPost(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sign In User and return their new session_id
         * @param {UserCredentials} [userCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signInPost(userCredentials?: UserCredentials, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionInfo>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).signInPost(userCredentials, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Sign Up User and return their new session_id
         * @param {NewUser} [newUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUpPost(newUser?: NewUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionInfo>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).signUpPost(newUser, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary HTML page when a Maker finishes connecting Stripe account. INTERNAL ONLY.
         * @param {string} userAccountId 
         * @param {string} userAccountEmail 
         * @param {string} stripeAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeAccountLinkRefreshGet(userAccountId: string, userAccountEmail: string, stripeAccountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).stripeAccountLinkRefreshGet(userAccountId, userAccountEmail, stripeAccountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary HTML page when a Maker doesn\'t finish connecting Stripe account. INTERNAL ONLY.
         * @param {string} userAccountId 
         * @param {string} userAccountEmail 
         * @param {string} stripeAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeAccountLinkReturnGet(userAccountId: string, userAccountEmail: string, stripeAccountId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).stripeAccountLinkReturnGet(userAccountId, userAccountEmail, stripeAccountId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary HTML page when an End User does not finish checkout process. INTERNAL ONLY.
         * @param {string} userAccountId 
         * @param {string} stripeAccountId 
         * @param {string} productName 
         * @param {string} stripeProductId 
         * @param {string} stripePriceId 
         * @param {string} userCustomerId 
         * @param {string} userCustomerEmail 
         * @param {string} stripeCustomerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeCheckoutSessionCancelGet(userAccountId: string, stripeAccountId: string, productName: string, stripeProductId: string, stripePriceId: string, userCustomerId: string, userCustomerEmail: string, stripeCustomerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).stripeCheckoutSessionCancelGet(userAccountId, stripeAccountId, productName, stripeProductId, stripePriceId, userCustomerId, userCustomerEmail, stripeCustomerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary HTML page when an End User successfully finishes Checkout process. INTERNAL ONLY.
         * @param {string} checkoutSessionId 
         * @param {string} userAccountId 
         * @param {string} stripeAccountId 
         * @param {string} productName 
         * @param {string} stripeProductId 
         * @param {string} stripePriceId 
         * @param {string} userCustomerId 
         * @param {string} userCustomerEmail 
         * @param {string} stripeCustomerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stripeCheckoutSessionSuccessGet(checkoutSessionId: string, userAccountId: string, stripeAccountId: string, productName: string, stripeProductId: string, stripePriceId: string, userCustomerId: string, userCustomerEmail: string, stripeCustomerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).stripeCheckoutSessionSuccessGet(checkoutSessionId, userAccountId, stripeAccountId, productName, stripeProductId, stripePriceId, userCustomerId, userCustomerEmail, stripeCustomerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Upload file to Backend file storage.
         * @param {string} category Category of file, possible values are \&#39;image\&#39;, \&#39;data\&#39;.
         * @param {string} [publicLink] If provide permanent public link to file.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFilePost(category: string, publicLink?: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileParams>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).uploadFilePost(category, publicLink, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when Maker on \'Data\' tab add a new Entity. Frontend sends EntityFullMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates Entity.
         * @param {EntityFullMetadata} [entityFullMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertEntityMetadataPost(entityFullMetadata?: EntityFullMetadata, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EntityFullMetadata>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).upsertEntityMetadataPost(entityFullMetadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when Maker on \'Publish\' tab makes changes to Product as a whole. Frontend sends ProductMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates ProductMetadata.
         * @param {string} sessionId 
         * @param {ProductMetadata} [productMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertProductMetadataPost(sessionId: string, productMetadata?: ProductMetadata, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductMetadata>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).upsertProductMetadataPost(sessionId, productMetadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when Maker on \'Publish\' tab makes changes to Product as a whole. It also has a parameter to publish or unpublish Product. Frontend sends ProductMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates ProductMetadata.
         * @param {string} sessionId 
         * @param {string} published 
         * @param {ProductMetadata} [productMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertPublishProductMetadataPost(sessionId: string, published: string, productMetadata?: ProductMetadata, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductMetadata>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).upsertPublishProductMetadataPost(sessionId, published, productMetadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Creates a Stripe Product for Connected Account to be able to subscribe.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {number} price 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertStripeProductPost(sessionId: string, productName: string, price: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).upsertStripeProductPost(sessionId, productName, price, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when Maker on \'Data\' tab makes changes to a Table. Frontend sends TableFullMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates TableMetadata with all Columns.
         * @param {string} sessionId 
         * @param {TableFullMetadata} [tableFullMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertTableMetadataPost(sessionId: string, tableFullMetadata?: TableFullMetadata, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableConstructor>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).upsertTableMetadataPost(sessionId, tableFullMetadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when Maker refreshes data in existing Table in their Product and uploads a file. File can be provided by either uploading using /upload_file call and providing filename or by providing file_link to publicly available file. Backend reads file, refreshes data in DataStore and returns a TableConstructor with data and metadata. Frontend should display refreshed Table in \'Data\' tab. In reality only data is refreshed and metadata is remained the same.
         * @summary Refresh table by uploadig file.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} tableName 
         * @param {string} [filename] 
         * @param {string} [fileLink] 
         * @param {DataSource} [dataSource] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertTableUploadFilePost(sessionId: string, productName: string, tableName: string, filename?: string, fileLink?: string, dataSource?: DataSource, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TableConstructor>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).upsertTableUploadFilePost(sessionId, productName, tableName, filename, fileLink, dataSource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This call is made when Maker on \'View\' tab makes changes to a View. Frontend sends ViewMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates ViewMetadata.
         * @param {string} sessionId 
         * @param {ViewMetadata} [viewMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertViewMetadataPost(sessionId: string, viewMetadata?: ViewMetadata, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewConstructor>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).upsertViewMetadataPost(sessionId, viewMetadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This call is made when Maker adds a new Table to their Product and uploads a file. File can be provided by either uploading using /upload_file call and providing filename or by providing file_link to publicly available file. Backend reads file, adds data to DataStore, if applicable, adds Views and returns a TableConstructor with Table metadata and Preview data. Frontend should display this new Table in \'Data\' tab.
         * @summary Add new Table by uploadig file.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} tableName 
         * @param {string} addDefaultViews 
         * @param {string} [filename] 
         * @param {string} [fileLink] 
         * @param {DataSource} [dataSource] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTableUploadFilePost(sessionId: string, productName: string, tableName: string, addDefaultViews: string, filename?: string, fileLink?: string, dataSource?: DataSource, options?: any): AxiosPromise<TableConstructor> {
            return DefaultApiFp(configuration).addTableUploadFilePost(sessionId, productName, tableName, addDefaultViews, filename, fileLink, dataSource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add test and demo accounts and data products. INTERNAL ONLY.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTestDataPost(options?: any): AxiosPromise<string> {
            return DefaultApiFp(configuration).addTestDataPost(options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when Maker adds a new View to their Product. Frontend sends Table name which new View should display and mode (Table or Card). Backend adds new View and returns a ViewConstructor with View metadata and Preview data. Frontend should display this new View in \'View\' tab.
         * @summary Add new View.
         * @param {string} sessionId 
         * @param {ViewMetadata} [viewMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addViewPost(sessionId: string, viewMetadata?: ViewMetadata, options?: any): AxiosPromise<ViewConstructor> {
            return DefaultApiFp(configuration).addViewPost(sessionId, viewMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels a Stripe Subscription for all End User to given Product.
         * @param {string} productName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelStripeAllProductSubscriptionPost(productName: string, options?: any): AxiosPromise<string> {
            return DefaultApiFp(configuration).cancelStripeAllProductSubscriptionPost(productName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancels a Stripe Subscription for current End User to given Product.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelStripeSubscriptionPost(sessionId: string, productName: string, options?: any): AxiosPromise<string> {
            return DefaultApiFp(configuration).cancelStripeSubscriptionPost(sessionId, productName, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when Maker creates a new Product and uploads a file. File can be provided by either uploading using /upload_file call and providing filename or by providing file_link to publicly available file. Backend reads file, adds data to DataStore, if applicable, adds Views and returns a ProductConstructor. Frontend should switch immidietely to \'Publish\' tab and display ProductConstructor.
         * @summary Create Product by uploadig file.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} tableName 
         * @param {string} addDefaultViews 
         * @param {string} [filename] 
         * @param {string} [fileLink] 
         * @param {DataSource} [dataSource] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductUploadFilePost(sessionId: string, productName: string, tableName: string, addDefaultViews: string, filename?: string, fileLink?: string, dataSource?: DataSource, options?: any): AxiosPromise<ProductConstructor> {
            return DefaultApiFp(configuration).createProductUploadFilePost(sessionId, productName, tableName, addDefaultViews, filename, fileLink, dataSource, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets file from Backend file storage.
         * @param {string} category Category of file, possible values are \&#39;image\&#39;, \&#39;data\&#39;.
         * @param {string} filename Filename as returned by /upload_file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileGet(category: string, filename: string, options?: any): AxiosPromise<string> {
            return DefaultApiFp(configuration).getFileGet(category, filename, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when Maker selects their product from their list. Backend returns a ProductConstructor and Frontend should switch immidietely \'Publish\' tab where ProductConstructor is displayed.
         * @summary Get ProductConsructor.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductConstructorGet(sessionId: string, productName: string, options?: any): AxiosPromise<ProductConstructor> {
            return DefaultApiFp(configuration).getProductConstructorGet(sessionId, productName, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when Maker click on \'My Data Products\'. Frontend should display list of those Product for Maker to select one.
         * @summary Get list of Products for current Maker.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductListPageGet(sessionId: string, options?: any): AxiosPromise<ProductListPage> {
            return DefaultApiFp(configuration).getProductListPageGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when End User visits a home page of a Product. This is how End User starts navigating the Product.
         * @summary Get Product home page View as seen by End User.
         * @param {string} productName 
         * @param {string} [sessionId] 
         * @param {DisplayParams} [displayParams] Params to display a View.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductPost(productName: string, sessionId?: string, displayParams?: DisplayParams, options?: any): AxiosPromise<ViewPage> {
            return DefaultApiFp(configuration).getProductPost(productName, sessionId, displayParams, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when Maker click on \'My Data Products\'. Frontend should display list of those Product for Maker to select one.
         * @summary Get list of Products for current Maker. OBSOLETE. Use /get_product_list_page instead.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductsGet(sessionId: string, options?: any): AxiosPromise<ProductMetadataList> {
            return DefaultApiFp(configuration).getProductsGet(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates and returns a URL to redirect to to connect a Maker to their Stripe account.
         * @param {string} sessionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeAccountLinkPost(sessionId: string, options?: any): AxiosPromise<StripeAccountLink> {
            return DefaultApiFp(configuration).getStripeAccountLinkPost(sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates and returns Stripe Checkout Session for an End User to subscribe for a Product.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStripeCheckoutSessionPost(sessionId: string, productName: string, options?: any): AxiosPromise<StripeCheckoutSession> {
            return DefaultApiFp(configuration).getStripeCheckoutSessionPost(sessionId, productName, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when Maker click on \'Data\' tab on one of tables. Backend sends back hard coded example. Backend sends back TableConstructor which contain Table metadata and Preview data to be displayed.
         * @summary Get TableConsructor example.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableConstructorExampleGet(options?: any): AxiosPromise<TableConstructor> {
            return DefaultApiFp(configuration).getTableConstructorExampleGet(options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when Maker click on \'Data\' tab on one of tables. Frontend sends request Product and Table. Backend sends back TableConstructor which contain Table metadata and Preview data to be displayed.
         * @summary Get TableConsructor.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} tableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableConstructorGet(sessionId: string, productName: string, tableName: string, options?: any): AxiosPromise<TableConstructor> {
            return DefaultApiFp(configuration).getTableConstructorGet(sessionId, productName, tableName, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when Maker click on \'View\' tab on one of Views. Frontend sends request Product and View. Backend sends back ViewConstructor which contain View Table metadata and Preview View to be displayed. Preview View should not be interactive.
         * @summary Get ViewConsructor.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} viewName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewConstructorGet(sessionId: string, productName: string, viewName: string, options?: any): AxiosPromise<ViewConstructor> {
            return DefaultApiFp(configuration).getViewConstructorGet(sessionId, productName, viewName, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when End User navigates a Product. When End User navigates to a Card View, a value and, optionally, column_name should be sent.
         * @summary Get View as seen by End User.
         * @param {string} productName 
         * @param {string} viewName 
         * @param {string} [sessionId] 
         * @param {string} [columnName] If row queried not by primary key, specify column name.
         * @param {string} [value] Value of primary key or specified column.
         * @param {ViewParams} [viewParams] Params to display a View.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getViewPost(productName: string, viewName: string, sessionId?: string, columnName?: string, value?: string, viewParams?: ViewParams, options?: any): AxiosPromise<ViewPage> {
            return DefaultApiFp(configuration).getViewPost(productName, viewName, sessionId, columnName, value, viewParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initializes server. Adds built-in entites and various data. INTERNAL ONLY.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializePost(options?: any): AxiosPromise<string> {
            return DefaultApiFp(configuration).initializePost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Allows to ping Server to make sure it\'s running. INTERNAL ONLY.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pingGet(options?: any): AxiosPromise<string> {
            return DefaultApiFp(configuration).pingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made to publish or unpublish Product.
         * @summary Add or updates ProductMetadata.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} published 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishProductPost(sessionId: string, productName: string, published: string, options?: any): AxiosPromise<ProductMetadata> {
            return DefaultApiFp(configuration).publishProductPost(sessionId, productName, published, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Refresh all stores and drops all the data. INTERNAL ONLY.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshStoresPost(options?: any): AxiosPromise<string> {
            return DefaultApiFp(configuration).refreshStoresPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign In User and return their new session_id
         * @param {UserCredentials} [userCredentials] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInPost(userCredentials?: UserCredentials, options?: any): AxiosPromise<SessionInfo> {
            return DefaultApiFp(configuration).signInPost(userCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sign Up User and return their new session_id
         * @param {NewUser} [newUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpPost(newUser?: NewUser, options?: any): AxiosPromise<SessionInfo> {
            return DefaultApiFp(configuration).signUpPost(newUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary HTML page when a Maker finishes connecting Stripe account. INTERNAL ONLY.
         * @param {string} userAccountId 
         * @param {string} userAccountEmail 
         * @param {string} stripeAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeAccountLinkRefreshGet(userAccountId: string, userAccountEmail: string, stripeAccountId: string, options?: any): AxiosPromise<string> {
            return DefaultApiFp(configuration).stripeAccountLinkRefreshGet(userAccountId, userAccountEmail, stripeAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary HTML page when a Maker doesn\'t finish connecting Stripe account. INTERNAL ONLY.
         * @param {string} userAccountId 
         * @param {string} userAccountEmail 
         * @param {string} stripeAccountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeAccountLinkReturnGet(userAccountId: string, userAccountEmail: string, stripeAccountId: string, options?: any): AxiosPromise<string> {
            return DefaultApiFp(configuration).stripeAccountLinkReturnGet(userAccountId, userAccountEmail, stripeAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary HTML page when an End User does not finish checkout process. INTERNAL ONLY.
         * @param {string} userAccountId 
         * @param {string} stripeAccountId 
         * @param {string} productName 
         * @param {string} stripeProductId 
         * @param {string} stripePriceId 
         * @param {string} userCustomerId 
         * @param {string} userCustomerEmail 
         * @param {string} stripeCustomerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeCheckoutSessionCancelGet(userAccountId: string, stripeAccountId: string, productName: string, stripeProductId: string, stripePriceId: string, userCustomerId: string, userCustomerEmail: string, stripeCustomerId: string, options?: any): AxiosPromise<string> {
            return DefaultApiFp(configuration).stripeCheckoutSessionCancelGet(userAccountId, stripeAccountId, productName, stripeProductId, stripePriceId, userCustomerId, userCustomerEmail, stripeCustomerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary HTML page when an End User successfully finishes Checkout process. INTERNAL ONLY.
         * @param {string} checkoutSessionId 
         * @param {string} userAccountId 
         * @param {string} stripeAccountId 
         * @param {string} productName 
         * @param {string} stripeProductId 
         * @param {string} stripePriceId 
         * @param {string} userCustomerId 
         * @param {string} userCustomerEmail 
         * @param {string} stripeCustomerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stripeCheckoutSessionSuccessGet(checkoutSessionId: string, userAccountId: string, stripeAccountId: string, productName: string, stripeProductId: string, stripePriceId: string, userCustomerId: string, userCustomerEmail: string, stripeCustomerId: string, options?: any): AxiosPromise<string> {
            return DefaultApiFp(configuration).stripeCheckoutSessionSuccessGet(checkoutSessionId, userAccountId, stripeAccountId, productName, stripeProductId, stripePriceId, userCustomerId, userCustomerEmail, stripeCustomerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload file to Backend file storage.
         * @param {string} category Category of file, possible values are \&#39;image\&#39;, \&#39;data\&#39;.
         * @param {string} [publicLink] If provide permanent public link to file.
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFilePost(category: string, publicLink?: string, file?: any, options?: any): AxiosPromise<FileParams> {
            return DefaultApiFp(configuration).uploadFilePost(category, publicLink, file, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when Maker on \'Data\' tab add a new Entity. Frontend sends EntityFullMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates Entity.
         * @param {EntityFullMetadata} [entityFullMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertEntityMetadataPost(entityFullMetadata?: EntityFullMetadata, options?: any): AxiosPromise<EntityFullMetadata> {
            return DefaultApiFp(configuration).upsertEntityMetadataPost(entityFullMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when Maker on \'Publish\' tab makes changes to Product as a whole. Frontend sends ProductMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates ProductMetadata.
         * @param {string} sessionId 
         * @param {ProductMetadata} [productMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertProductMetadataPost(sessionId: string, productMetadata?: ProductMetadata, options?: any): AxiosPromise<ProductMetadata> {
            return DefaultApiFp(configuration).upsertProductMetadataPost(sessionId, productMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when Maker on \'Publish\' tab makes changes to Product as a whole. It also has a parameter to publish or unpublish Product. Frontend sends ProductMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates ProductMetadata.
         * @param {string} sessionId 
         * @param {string} published 
         * @param {ProductMetadata} [productMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertPublishProductMetadataPost(sessionId: string, published: string, productMetadata?: ProductMetadata, options?: any): AxiosPromise<ProductMetadata> {
            return DefaultApiFp(configuration).upsertPublishProductMetadataPost(sessionId, published, productMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a Stripe Product for Connected Account to be able to subscribe.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {number} price 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertStripeProductPost(sessionId: string, productName: string, price: number, options?: any): AxiosPromise<string> {
            return DefaultApiFp(configuration).upsertStripeProductPost(sessionId, productName, price, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when Maker on \'Data\' tab makes changes to a Table. Frontend sends TableFullMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates TableMetadata with all Columns.
         * @param {string} sessionId 
         * @param {TableFullMetadata} [tableFullMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertTableMetadataPost(sessionId: string, tableFullMetadata?: TableFullMetadata, options?: any): AxiosPromise<TableConstructor> {
            return DefaultApiFp(configuration).upsertTableMetadataPost(sessionId, tableFullMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when Maker refreshes data in existing Table in their Product and uploads a file. File can be provided by either uploading using /upload_file call and providing filename or by providing file_link to publicly available file. Backend reads file, refreshes data in DataStore and returns a TableConstructor with data and metadata. Frontend should display refreshed Table in \'Data\' tab. In reality only data is refreshed and metadata is remained the same.
         * @summary Refresh table by uploadig file.
         * @param {string} sessionId 
         * @param {string} productName 
         * @param {string} tableName 
         * @param {string} [filename] 
         * @param {string} [fileLink] 
         * @param {DataSource} [dataSource] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertTableUploadFilePost(sessionId: string, productName: string, tableName: string, filename?: string, fileLink?: string, dataSource?: DataSource, options?: any): AxiosPromise<TableConstructor> {
            return DefaultApiFp(configuration).upsertTableUploadFilePost(sessionId, productName, tableName, filename, fileLink, dataSource, options).then((request) => request(axios, basePath));
        },
        /**
         * This call is made when Maker on \'View\' tab makes changes to a View. Frontend sends ViewMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
         * @summary Add or updates ViewMetadata.
         * @param {string} sessionId 
         * @param {ViewMetadata} [viewMetadata] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertViewMetadataPost(sessionId: string, viewMetadata?: ViewMetadata, options?: any): AxiosPromise<ViewConstructor> {
            return DefaultApiFp(configuration).upsertViewMetadataPost(sessionId, viewMetadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * This call is made when Maker adds a new Table to their Product and uploads a file. File can be provided by either uploading using /upload_file call and providing filename or by providing file_link to publicly available file. Backend reads file, adds data to DataStore, if applicable, adds Views and returns a TableConstructor with Table metadata and Preview data. Frontend should display this new Table in \'Data\' tab.
     * @summary Add new Table by uploadig file.
     * @param {string} sessionId 
     * @param {string} productName 
     * @param {string} tableName 
     * @param {string} addDefaultViews 
     * @param {string} [filename] 
     * @param {string} [fileLink] 
     * @param {DataSource} [dataSource] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addTableUploadFilePost(sessionId: string, productName: string, tableName: string, addDefaultViews: string, filename?: string, fileLink?: string, dataSource?: DataSource, options?: any) {
        return DefaultApiFp(this.configuration).addTableUploadFilePost(sessionId, productName, tableName, addDefaultViews, filename, fileLink, dataSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add test and demo accounts and data products. INTERNAL ONLY.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addTestDataPost(options?: any) {
        return DefaultApiFp(this.configuration).addTestDataPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when Maker adds a new View to their Product. Frontend sends Table name which new View should display and mode (Table or Card). Backend adds new View and returns a ViewConstructor with View metadata and Preview data. Frontend should display this new View in \'View\' tab.
     * @summary Add new View.
     * @param {string} sessionId 
     * @param {ViewMetadata} [viewMetadata] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public addViewPost(sessionId: string, viewMetadata?: ViewMetadata, options?: any) {
        return DefaultApiFp(this.configuration).addViewPost(sessionId, viewMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels a Stripe Subscription for all End User to given Product.
     * @param {string} productName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelStripeAllProductSubscriptionPost(productName: string, options?: any) {
        return DefaultApiFp(this.configuration).cancelStripeAllProductSubscriptionPost(productName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancels a Stripe Subscription for current End User to given Product.
     * @param {string} sessionId 
     * @param {string} productName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelStripeSubscriptionPost(sessionId: string, productName: string, options?: any) {
        return DefaultApiFp(this.configuration).cancelStripeSubscriptionPost(sessionId, productName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when Maker creates a new Product and uploads a file. File can be provided by either uploading using /upload_file call and providing filename or by providing file_link to publicly available file. Backend reads file, adds data to DataStore, if applicable, adds Views and returns a ProductConstructor. Frontend should switch immidietely to \'Publish\' tab and display ProductConstructor.
     * @summary Create Product by uploadig file.
     * @param {string} sessionId 
     * @param {string} productName 
     * @param {string} tableName 
     * @param {string} addDefaultViews 
     * @param {string} [filename] 
     * @param {string} [fileLink] 
     * @param {DataSource} [dataSource] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createProductUploadFilePost(sessionId: string, productName: string, tableName: string, addDefaultViews: string, filename?: string, fileLink?: string, dataSource?: DataSource, options?: any) {
        return DefaultApiFp(this.configuration).createProductUploadFilePost(sessionId, productName, tableName, addDefaultViews, filename, fileLink, dataSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets file from Backend file storage.
     * @param {string} category Category of file, possible values are \&#39;image\&#39;, \&#39;data\&#39;.
     * @param {string} filename Filename as returned by /upload_file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFileGet(category: string, filename: string, options?: any) {
        return DefaultApiFp(this.configuration).getFileGet(category, filename, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when Maker selects their product from their list. Backend returns a ProductConstructor and Frontend should switch immidietely \'Publish\' tab where ProductConstructor is displayed.
     * @summary Get ProductConsructor.
     * @param {string} sessionId 
     * @param {string} productName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProductConstructorGet(sessionId: string, productName: string, options?: any) {
        return DefaultApiFp(this.configuration).getProductConstructorGet(sessionId, productName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when Maker click on \'My Data Products\'. Frontend should display list of those Product for Maker to select one.
     * @summary Get list of Products for current Maker.
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProductListPageGet(sessionId: string, options?: any) {
        return DefaultApiFp(this.configuration).getProductListPageGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when End User visits a home page of a Product. This is how End User starts navigating the Product.
     * @summary Get Product home page View as seen by End User.
     * @param {string} productName 
     * @param {string} [sessionId] 
     * @param {DisplayParams} [displayParams] Params to display a View.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProductPost(productName: string, sessionId?: string, displayParams?: DisplayParams, options?: any) {
        return DefaultApiFp(this.configuration).getProductPost(productName, sessionId, displayParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when Maker click on \'My Data Products\'. Frontend should display list of those Product for Maker to select one.
     * @summary Get list of Products for current Maker. OBSOLETE. Use /get_product_list_page instead.
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getProductsGet(sessionId: string, options?: any) {
        return DefaultApiFp(this.configuration).getProductsGet(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates and returns a URL to redirect to to connect a Maker to their Stripe account.
     * @param {string} sessionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStripeAccountLinkPost(sessionId: string, options?: any) {
        return DefaultApiFp(this.configuration).getStripeAccountLinkPost(sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates and returns Stripe Checkout Session for an End User to subscribe for a Product.
     * @param {string} sessionId 
     * @param {string} productName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStripeCheckoutSessionPost(sessionId: string, productName: string, options?: any) {
        return DefaultApiFp(this.configuration).getStripeCheckoutSessionPost(sessionId, productName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when Maker click on \'Data\' tab on one of tables. Backend sends back hard coded example. Backend sends back TableConstructor which contain Table metadata and Preview data to be displayed.
     * @summary Get TableConsructor example.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTableConstructorExampleGet(options?: any) {
        return DefaultApiFp(this.configuration).getTableConstructorExampleGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when Maker click on \'Data\' tab on one of tables. Frontend sends request Product and Table. Backend sends back TableConstructor which contain Table metadata and Preview data to be displayed.
     * @summary Get TableConsructor.
     * @param {string} sessionId 
     * @param {string} productName 
     * @param {string} tableName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTableConstructorGet(sessionId: string, productName: string, tableName: string, options?: any) {
        return DefaultApiFp(this.configuration).getTableConstructorGet(sessionId, productName, tableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when Maker click on \'View\' tab on one of Views. Frontend sends request Product and View. Backend sends back ViewConstructor which contain View Table metadata and Preview View to be displayed. Preview View should not be interactive.
     * @summary Get ViewConsructor.
     * @param {string} sessionId 
     * @param {string} productName 
     * @param {string} viewName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getViewConstructorGet(sessionId: string, productName: string, viewName: string, options?: any) {
        return DefaultApiFp(this.configuration).getViewConstructorGet(sessionId, productName, viewName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when End User navigates a Product. When End User navigates to a Card View, a value and, optionally, column_name should be sent.
     * @summary Get View as seen by End User.
     * @param {string} productName 
     * @param {string} viewName 
     * @param {string} [sessionId] 
     * @param {string} [columnName] If row queried not by primary key, specify column name.
     * @param {string} [value] Value of primary key or specified column.
     * @param {ViewParams} [viewParams] Params to display a View.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getViewPost(productName: string, viewName: string, sessionId?: string, columnName?: string, value?: string, viewParams?: ViewParams, options?: any) {
        return DefaultApiFp(this.configuration).getViewPost(productName, viewName, sessionId, columnName, value, viewParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initializes server. Adds built-in entites and various data. INTERNAL ONLY.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public initializePost(options?: any) {
        return DefaultApiFp(this.configuration).initializePost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Allows to ping Server to make sure it\'s running. INTERNAL ONLY.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pingGet(options?: any) {
        return DefaultApiFp(this.configuration).pingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made to publish or unpublish Product.
     * @summary Add or updates ProductMetadata.
     * @param {string} sessionId 
     * @param {string} productName 
     * @param {string} published 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public publishProductPost(sessionId: string, productName: string, published: string, options?: any) {
        return DefaultApiFp(this.configuration).publishProductPost(sessionId, productName, published, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Refresh all stores and drops all the data. INTERNAL ONLY.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public refreshStoresPost(options?: any) {
        return DefaultApiFp(this.configuration).refreshStoresPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign In User and return their new session_id
     * @param {UserCredentials} [userCredentials] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public signInPost(userCredentials?: UserCredentials, options?: any) {
        return DefaultApiFp(this.configuration).signInPost(userCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sign Up User and return their new session_id
     * @param {NewUser} [newUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public signUpPost(newUser?: NewUser, options?: any) {
        return DefaultApiFp(this.configuration).signUpPost(newUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary HTML page when a Maker finishes connecting Stripe account. INTERNAL ONLY.
     * @param {string} userAccountId 
     * @param {string} userAccountEmail 
     * @param {string} stripeAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stripeAccountLinkRefreshGet(userAccountId: string, userAccountEmail: string, stripeAccountId: string, options?: any) {
        return DefaultApiFp(this.configuration).stripeAccountLinkRefreshGet(userAccountId, userAccountEmail, stripeAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary HTML page when a Maker doesn\'t finish connecting Stripe account. INTERNAL ONLY.
     * @param {string} userAccountId 
     * @param {string} userAccountEmail 
     * @param {string} stripeAccountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stripeAccountLinkReturnGet(userAccountId: string, userAccountEmail: string, stripeAccountId: string, options?: any) {
        return DefaultApiFp(this.configuration).stripeAccountLinkReturnGet(userAccountId, userAccountEmail, stripeAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary HTML page when an End User does not finish checkout process. INTERNAL ONLY.
     * @param {string} userAccountId 
     * @param {string} stripeAccountId 
     * @param {string} productName 
     * @param {string} stripeProductId 
     * @param {string} stripePriceId 
     * @param {string} userCustomerId 
     * @param {string} userCustomerEmail 
     * @param {string} stripeCustomerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stripeCheckoutSessionCancelGet(userAccountId: string, stripeAccountId: string, productName: string, stripeProductId: string, stripePriceId: string, userCustomerId: string, userCustomerEmail: string, stripeCustomerId: string, options?: any) {
        return DefaultApiFp(this.configuration).stripeCheckoutSessionCancelGet(userAccountId, stripeAccountId, productName, stripeProductId, stripePriceId, userCustomerId, userCustomerEmail, stripeCustomerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary HTML page when an End User successfully finishes Checkout process. INTERNAL ONLY.
     * @param {string} checkoutSessionId 
     * @param {string} userAccountId 
     * @param {string} stripeAccountId 
     * @param {string} productName 
     * @param {string} stripeProductId 
     * @param {string} stripePriceId 
     * @param {string} userCustomerId 
     * @param {string} userCustomerEmail 
     * @param {string} stripeCustomerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public stripeCheckoutSessionSuccessGet(checkoutSessionId: string, userAccountId: string, stripeAccountId: string, productName: string, stripeProductId: string, stripePriceId: string, userCustomerId: string, userCustomerEmail: string, stripeCustomerId: string, options?: any) {
        return DefaultApiFp(this.configuration).stripeCheckoutSessionSuccessGet(checkoutSessionId, userAccountId, stripeAccountId, productName, stripeProductId, stripePriceId, userCustomerId, userCustomerEmail, stripeCustomerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload file to Backend file storage.
     * @param {string} category Category of file, possible values are \&#39;image\&#39;, \&#39;data\&#39;.
     * @param {string} [publicLink] If provide permanent public link to file.
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public uploadFilePost(category: string, publicLink?: string, file?: any, options?: any) {
        return DefaultApiFp(this.configuration).uploadFilePost(category, publicLink, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when Maker on \'Data\' tab add a new Entity. Frontend sends EntityFullMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
     * @summary Add or updates Entity.
     * @param {EntityFullMetadata} [entityFullMetadata] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public upsertEntityMetadataPost(entityFullMetadata?: EntityFullMetadata, options?: any) {
        return DefaultApiFp(this.configuration).upsertEntityMetadataPost(entityFullMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when Maker on \'Publish\' tab makes changes to Product as a whole. Frontend sends ProductMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
     * @summary Add or updates ProductMetadata.
     * @param {string} sessionId 
     * @param {ProductMetadata} [productMetadata] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public upsertProductMetadataPost(sessionId: string, productMetadata?: ProductMetadata, options?: any) {
        return DefaultApiFp(this.configuration).upsertProductMetadataPost(sessionId, productMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when Maker on \'Publish\' tab makes changes to Product as a whole. It also has a parameter to publish or unpublish Product. Frontend sends ProductMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
     * @summary Add or updates ProductMetadata.
     * @param {string} sessionId 
     * @param {string} published 
     * @param {ProductMetadata} [productMetadata] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public upsertPublishProductMetadataPost(sessionId: string, published: string, productMetadata?: ProductMetadata, options?: any) {
        return DefaultApiFp(this.configuration).upsertPublishProductMetadataPost(sessionId, published, productMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a Stripe Product for Connected Account to be able to subscribe.
     * @param {string} sessionId 
     * @param {string} productName 
     * @param {number} price 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public upsertStripeProductPost(sessionId: string, productName: string, price: number, options?: any) {
        return DefaultApiFp(this.configuration).upsertStripeProductPost(sessionId, productName, price, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when Maker on \'Data\' tab makes changes to a Table. Frontend sends TableFullMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
     * @summary Add or updates TableMetadata with all Columns.
     * @param {string} sessionId 
     * @param {TableFullMetadata} [tableFullMetadata] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public upsertTableMetadataPost(sessionId: string, tableFullMetadata?: TableFullMetadata, options?: any) {
        return DefaultApiFp(this.configuration).upsertTableMetadataPost(sessionId, tableFullMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when Maker refreshes data in existing Table in their Product and uploads a file. File can be provided by either uploading using /upload_file call and providing filename or by providing file_link to publicly available file. Backend reads file, refreshes data in DataStore and returns a TableConstructor with data and metadata. Frontend should display refreshed Table in \'Data\' tab. In reality only data is refreshed and metadata is remained the same.
     * @summary Refresh table by uploadig file.
     * @param {string} sessionId 
     * @param {string} productName 
     * @param {string} tableName 
     * @param {string} [filename] 
     * @param {string} [fileLink] 
     * @param {DataSource} [dataSource] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public upsertTableUploadFilePost(sessionId: string, productName: string, tableName: string, filename?: string, fileLink?: string, dataSource?: DataSource, options?: any) {
        return DefaultApiFp(this.configuration).upsertTableUploadFilePost(sessionId, productName, tableName, filename, fileLink, dataSource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This call is made when Maker on \'View\' tab makes changes to a View. Frontend sends ViewMetadata, Backend uses only certain fields from entire structure, updates it in MetadataStore and returns as it stored in MetadataStore.
     * @summary Add or updates ViewMetadata.
     * @param {string} sessionId 
     * @param {ViewMetadata} [viewMetadata] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public upsertViewMetadataPost(sessionId: string, viewMetadata?: ViewMetadata, options?: any) {
        return DefaultApiFp(this.configuration).upsertViewMetadataPost(sessionId, viewMetadata, options).then((request) => request(this.axios, this.basePath));
    }
}


